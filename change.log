

"define class"

Set subclass: #IdentitySet
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

WinStructure subclass: #WinStructArray
  instanceVariableNames: 
    'collection '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

WinStructure subclass: #WinWindowPlacement
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

WinStructure subclass: #WinLogPalette
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

WinStructure subclass: #WinDrawItemStruct
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    'WinConstants '!

"define class"  

WinLogicalObject subclass: #WinLogicalPalette
  instanceVariableNames: 
    'logPalette '
  classVariableNames: 
    'PaletteDictionary MaxPalettes '
  poolDictionaries: 
    'WinConstants '!

"define class" 

GraphicsMedium subclass: #StoredPicture
  instanceVariableNames: 
    'hMetaFile apmHeader '
  classVariableNames: ''
  poolDictionaries: 
    'WinConstants '!

!IdentitySet class methods !  !

!IdentitySet methods !   
findElementIndex: anObject
        "Private - Answer the index position of anObject in the
         receiver or the first empty element position."

    | index indexedObject lastIndex |
    lastIndex := contents size.
    index := (anObject basicHash) \\ lastIndex + 1.
    [ (indexedObject := contents at: index) == anObject ]
        whileFalse: [
            (indexedObject == nil)
                ifTrue: [^index].
            (index := index + 1) > lastIndex
                ifTrue: [ "index wraparound"
                    index := 1]].
    ^index!    !

!StoredPicture class methods !   
readMetaFileHeader: aFileStream
        "Private - Read the metafile header from aFileStream.
          Answer a WinStructure."
    | header |
    header := WinStructure new: 18.
    aFileStream getBytesFor: header contents.
    ^header!   
readPlaceableHeader: aFileStream
        "Private - Read the placeable file header from aFileStream.
          Answer a WinStructure."
    | header |
    header := WinStructure new: 22.
    aFileStream getBytesFor: header contents.
    ^header!  !

!StoredPicture methods ! 
isStoredPicture
        "Answer whether the receiver is an instance of
        StoredPicture or one of its subclasses."
    ^true! 
load: aFileName
        "Load a metafile from aFileName."
    | file key bits mfHeader hMem |
    file := File pathName: aFileName.
    key := file nextULong.
    key = 16r9AC6CDD7
        ifTrue: [           "Aldus Placeable Metafile (APM) format"
            apmHeader := StoredPicture readPlaceableHeader: file.
            file position: 22.              "position to read metafile header"
           mfHeader := StoredPicture readMetaFileHeader: file.
            file position: 22.              "position to read metafile header"
           "allocate memory for the metafile."
            bits := ByteArray new: (mfHeader uLongAtOffset: 6) * 2.
            file getBytesFor: bits.
            file close.
            hMem := WinAddress memoryHandleFrom: bits.
            KernelLibrary globalLock: hMem.
            hMetaFile := GDILibrary setMetaFileBits:  hMem.
            KernelLibrary globalUnlock: hMem]
        ifFalse: [          "standard metafile format"
            file close.
            hMetaFile := GDILibrary getMetaFile: aFileName asParameter].
    hMetaFile = 0
        ifTrue: [^self error: 'Load metafile error']!
play: aGraphicsTool
        "Display the receiver through aGraphicsTool."
    | rect |
    apmHeader == nil ifFalse: [
        rect := (apmHeader uShortAtOffset: 8) @ (apmHeader uShortAtOffset: 10)
            rightBottom: (apmHeader uShortAtOffset: 12) @ (apmHeader uShortAtOffset: 14).
        aGraphicsTool setMapMode: MmAnisotropic.
        aGraphicsTool setWindowOrg: rect leftTop;
            setWindowExt: rect extent.
        "The following can be changed to scale and translate
          the picture accordingly."
        aGraphicsTool setViewportOrg: 0 @ 0.
        aGraphicsTool setViewportExt: aGraphicsTool extent].
    (GDILibrary
        playMetaFile: aGraphicsTool handle
        with: hMetaFile) = 0
            ifTrue: [^self error: 'play metafile error']!  !

!WinDrawItemStruct class methods !   
sizeInBytes
         "Private - Answer the default size in bytes."
    ^26!   !

!WinDrawItemStruct methods ! 
itemActionDrawEntireItem
        " Answer whether this is a request to draw the
        entire item, with selection and focus. "
    ^(self itemAction & OdaDrawentire) = OdaDrawentire!   
itemActionFocus
        " Answer whether the item action is focus. "
    ^(self itemAction & OdaFocus) = OdaFocus!  
itemActionSelect
        " Answer whether the item action is select. "
    ^(self itemAction & OdaSelect) = OdaSelect!  
itemHasFocus
        "Answer whether the item has the input focus."
    ^(self itemState & OdsFocus) = OdsFocus!
itemIsDisabled
        " Answer whether the item is disabled. "
    ^(self itemState & OdsDisabled) = OdsDisabled!  
itemIsSelected
        " Answer whether the item is selected. "
    ^(self itemState & OdsSelected) = OdsSelected!    !

!WinLogicalPalette class methods !   
anchorDictionary
        "Private - Answer the dictionary holding all
         instances of the receiver class."
    ^PaletteDictionary!   
fromStruct: aWinLogPalette
        "Private - Answer a new logical palette."
    ^self new
        fromStruct: aWinLogPalette! 
fromWinLogPalette: aWinLogPalette
        "Answer a logical palette created from aWinLogPalette
                 structure."
    ^self anchorDictionary
        at: aWinLogPalette
        ifAbsent: [
            self fromStruct: aWinLogPalette]!
initialize
        "Private - Initialize class variables.
                 WinLogicalPalette initialize."
    PaletteDictionary := Dictionary new.
    MaxPalettes := 16.
    self stockObject: DefaultPalette.
    self allInstancesPrim do: [:each | each initHandle].!   
stockObject: constant
        "Private - Answer a windows logical object
         with attributes in anArray."
    | aHandle struc |
    aHandle := GDILibrary getStockObject: constant.
    struc := self winStruct.
    "GDILibrary
        getObject: aHandle
        count: struc size
        lpObject: struc asParameter."
    ^(self new
        stockObject: constant;
        fromStruct: struc)!
threshold
        "Private - Answer max number of brushes causing
         cleanup."
    ^MaxPalettes! 
winStruct
        "Private - Answer Windows structure for receiver."
    ^WinLogPalette new!  !

!WinLogicalPalette methods ! 
attributeArray
        "Private - Answer attributes as an array."
        ^logPalette!  
fromStruct: struc
        "Private - Answer an instance with attributes
         specified in anArray."
    logPalette := struc.
    self createObject!   
getHandle
        "Private - Answer handle after creating
         the windows object."
    | aHandle aBrushStruct |
    stockObject notNil
        ifTrue: [^GraphicsTool getStockObject: stockObject].
    (aHandle :=
        GDILibrary createPalette: logPalette asParameter)
                = 0
                    ifTrue: [self error: 'Create palette failed']
                    ifFalse: [^aHandle]! !

!WinLogPalette class methods !   
fromRgbColor: aByteArray
    " Answer an instance of the receiver with its
        entries copied from aByteArray ."
    ^self fromRgbColor: aByteArray entries: (aByteArray size) // 4.!  
fromRgbColor: anArrayOfRgbQuads entries: anInteger
    " Answer an instance of the receiver with at most anInteger
    of its  entries copied from aByteArray .  Note that while a
    palette entry is stored as Red-Green-Blue, the RGBquad
    data is actually stored as Blue-Green-Red.
    Look at the structure definitions for PALETTEENTRY and RGBQUAD
    in windows.h."
    | logPalette aByteArray count|
    count := anArrayOfRgbQuads size.
    aByteArray  := ByteArray new: count.
    0 to: ( (count // 4) - 1 )  do:[ :i |
      aByteArray at: (i * 4 + 1) put: (anArrayOfRgbQuads at: (i * 4 + 3)).
      aByteArray at: (i * 4 + 2) put: (anArrayOfRgbQuads at: (i * 4 + 2)).
      aByteArray at: (i * 4 + 3) put: (anArrayOfRgbQuads at: (i * 4 + 1)).
      aByteArray at: (i * 4 + 4) put: 0. ].

   anInteger < ( aByteArray size  / 4 )
    ifTrue: [
        logPalette := self new: ( 4 + ( anInteger * 4 ) ).
        logPalette uShortAtOffset: 0 put: 16r300.
        logPalette  uShortAtOffset: 2 put: anInteger.
        logPalette contents replaceFrom: 5 to: ( 4 + ( anInteger * 4 ) )
                                        with: aByteArray startingAt: 1]
    ifFalse: [
        logPalette := self new: ( 4 + ( aByteArray size ) ).
        logPalette uShortAtOffset: 0 put: 16r300.
        logPalette  uShortAtOffset: 2 put:  ( ( aByteArray size) /4 ).
        logPalette bytesAtOffset: 4 put: aByteArray].

        ^logPalette!   
sizeInBytes
         "Private - Answer the default size in bytes."
    ^1028! !

!WinLogPalette methods ! 
= aWinLogPalette
                "Answer true if the contents of the receiver are equal
                 to the contents of aWinLogPalette."
        ^(self contents = aWinLogPalette contents)!   
hash
        "Answer the size of the receiver as its hash value."
        ^contents hash! !

!WinStructArray class methods !  
fromCollection: aCollection
        "Answer a new instance of the receiver
         which contains copies of all the structures
         in aCollection."
    ^self new
        collection: aCollection!   !

!WinStructArray methods !
asParameter
        "Answer the receiver in a form suitable for passing
         to an API call: copy the contained structures
         into the contents instance variable."
    | size byteArray offset |
    size := collection inject: 0 into: [ :bytes :item |
        bytes + item contents size ].
    byteArray := ByteArray new: size.
    offset := 1.
    collection do: [ :item |
        byteArray
            replaceFrom: offset
            to: offset + item contents size - 1
            with: item contents
            startingAt: 1.
        offset := offset + item contents size ].
    contents := byteArray.
    ^contents!
collection
    ^collection!  
collection: aCollection
        "Private - set the collection of structures
         that the receiver contains to aCollection."
    collection := aCollection!  !

!WinWindowPlacement class methods !  
inspectorFields
        "Answer the names of the fields contained in this kind of definition."
    ^self inspectorClass fields: #(
        length
        flags
        showCmd
        ptMinPosition
        ptMaxPosition
        rcNormalPosition
    )!  
new

    ^super new initialize! 
sizeInBytes
         "Private - Answer the default size in bytes."
    ^22!   !

!WinWindowPlacement methods !
flags
    ^self uShortAtOffset: 2!   
initialize
    self uShortAtOffset: 0 put: self contents size!   
length
    ^self uShortAtOffset: 0!  
printOn: aStream
    "Append the ASCII representation
    of the receiver to aStream."

    super printOn: aStream.
    aStream
        nextPut: $( ;
        nextPutAll: 'show('; print: self showCmd; nextPut: $);
        nextPutAll: ' normal('; print: self rcNormalPosition; nextPut: $);
        nextPut: $).!
ptMaxPosition
    ^WinPoint usingBytes: ( self bytesAtOffset: 10 count: WinPoint sizeInBytes )!  
ptMinPosition
    ^WinPoint usingBytes: ( self bytesAtOffset: 6 count: WinPoint sizeInBytes )!   
rcNormalPosition
    ^WinRectangle usingBytes: ( self bytesAtOffset: 14 count: WinRectangle sizeInBytes )!   
showCmd
    ^self uShortAtOffset: 4!   !

!ApplicationWindow methods ! 
childrenAffectingClientArea
    "Private - Answer the children that reduces
    the amount of visible client area in the receiver"

    ^self propertyAt: #childrenAffectingClientArea
        ifAbsent: [ OrderedCollection new ]!  
childrenAffectingClientArea: anOrderedCollection
    "Private - Set the children that reduces
    the amount of visible client area in the receiver"

    ^self propertyAt: #childrenAffectingClientArea
        put: anOrderedCollection!   
isApplicationWindow
        "Answer true if receiver is a kind of ApplicationWindow."
    ^true!
ownerDrawPen
        "Private - answer the pen to be used for drawing
        owner drawn items.  When drawing owner drawn
        menu items, use the menu window's pen."
    ^menuWindow pen!   
remove: anObject interestIn: aFacet
        "Remove anObject as a dependent of aFacet in the receiver.
         anObject."
    | list |
    list := dependents at: aFacet ifAbsent: [ ^nil ].
    list remove: anObject ifAbsent: [ nil ].
    list isEmpty ifTrue: [ dependents removeKey: aFacet ]!   
resizeRectangleFor: aRectangle
        "Private - Answer the rectangle to
        use to resize the receiver to aRectangle."

    ^aRectangle!
subPaneWithFocus
        "Answer the SubPane of the receiver that last had the focus"

    ^self
        propertyAt: #focusWindow
        ifAbsentPut: [ self searchForDefaultTextPane ]!
subPaneWithFocus: aSubPane
        "Private - remember the SubPane of the receiver
         that last had the focus"

    self propertyAt: #focusWindow put: aSubPane!
validateBuild
        "Private - Create or recreate the window for the receiver
        without showing it."
    | rect |
    CursorManager execute change.
    self buildWindow isNil ifTrue:[CursorManager normal change.^nil].
    rect := 0@0 extent: rectangle extent.
    rectangle := 0 @ 0 extent: 0@ 0.
    self resize: rect.
    children do: [:subpane | subpane sendInputEvent: #validate]. "wmCreate:with: may not have returned yet"
    collapsed isNil ifTrue: [collapsed := 0].
    CursorManager normal change.!
wmQuerydragicon: wordInteger with:longInteger
    "Private - Answer the icon handle"
    | icon |
    ( icon := self icon ) isNil
    	ifTrue: [ ^nil ].
    ^icon handle!   
wmSize: wordInteger with: longInteger
        "Private - Process the window resizing message."
    | extent |
    "do nothing if being minimized"
    wordInteger = Sizeiconic ifTrue: [ ^nil ].
    extent := ( ( WinPoint new:4 ) uLongAtOffset: 0 put: longInteger ) asPoint.
    ( extent x = 0 or: [ extent y = 0 ] )
        ifFalse: [ self resize: ( 0 @ 0 extent: extent ) ].
    ^nil!    !

!ByteArray methods ! 
dumpOn: aStream base: radix
        "Dump the receiver's bytes onto aStream using
        the given radix."

    ^self dumpOn: aStream base: radix bytes: 1!  
dumpOn: aStream base: radix bytes: oneTwoFour
        "Dump the receiver's bytes onto aStream using
        the given radix, and oneTwoFour specifying the number
        of bytes per chunk."
    | fieldWidth string lineLength columnIndex byte asciiStream byteValues |
    byteValues :=  #( 1 256 65536 16777216 ).
    lineLength := 16.
    fieldWidth := ( ( ( 2 raisedToInteger: oneTwoFour * 8 ) - 1 ) radix: radix showRadix: false ) size.
    columnIndex := 0.
    1 to: self size by: oneTwoFour do: [ :byteIndex |
        byte := 0.
        1 to: oneTwoFour do: [:i |
            byteIndex + i - 1 > self size ifFalse: [
                byte := byte + ( ( self at: byteIndex + i - 1 ) * ( byteValues at: i ) ) ] ].
        byteIndex - 1 \\ lineLength = 0 ifTrue: [
            asciiStream := String new asStream.
            string := byteIndex  - 1 printPaddedWith: $0 to: 4 base: 16.
            aStream nextPutAll: '<16r', string, '>  ' ].
        string := byte printPaddedWith: $0 to: fieldWidth base: radix.
        aStream nextPutAll: string, ' '.
        byteIndex \\ 4 = 0 ifTrue: [ aStream nextPutAll: ' ' ].
        1 to: oneTwoFour do: [:i |
            byteIndex + i - 1 > self size ifFalse: [
                byte := self at: byteIndex + i - 1.
                asciiStream nextPut: ( byte < 32 ifTrue: [ $. ] ifFalse: [ byte asCharacter ] ) ] ].
        byteIndex + oneTwoFour - 1 \\ lineLength = 0 ifTrue: [
            aStream nextPutAll: ' ', asciiStream contents; cr ] ].

    self size \\ lineLength = 0 ifFalse: [
        self size + 1 to: ( self size + lineLength truncateTo: lineLength ) do: [ :byteIndex |
            aStream nextPutAll: ( ( String new: fieldWidth + 1 ) atAllPut: $ ).
            byteIndex \\ 4 = 0 ifTrue: [ aStream nextPutAll: ' ' ] ].
        aStream nextPutAll: ' ', asciiStream contents ]! 
dumpString
        "Dump the receiver's bytes in hex."

    ^self dumpStringBase: 16!  
dumpStringBase: radix
        "Answer a String which contains a dump of the receiver's bytes
        in the given radix."

    ^self dumpStringBase: radix bytes: 1!  
dumpStringBase: radix bytes: oneTwoFour
        "Answer a String which contains a dump of the receiver's bytes
        in the given radix, where oneTwoFour specifies the number
        of bytes per chunk."
    | aStream |
    aStream := String new asStream.
    self dumpOn: aStream base: radix bytes: oneTwoFour.
    ^aStream contents! !

!CallBack class methods !
exit
        "Private - Clean up CallBAck class."
   " KernelLibrary freeSelector: LpDataCallBackEntry // 65536.        "!  
startUp
        "Private - Initialize the class variables."
    | hCodeCallBackEntry  |

    LpfnSTCallBack :=
       WinAddress fromString: (KernelLibrary
                  getProcAddress: WIN hInstanceDLL
                  procName: 'STCallBackProc' asParameter).
    CallBackTable := Array new: self maxNumCallBack.
    LpCodeCallBackEntry := WinAddress integerFrom:
                           (VWVMLibrary getObjectAddress: VmCallbackentry).

    hCodeCallBackEntry := WinAddress loWordFrom:
                (KernelLibrary globalHandle: LpCodeCallBackEntry //65536 ).
    hCodeCallBackEntry := KernelLibrary
                              globalReAlloc: hCodeCallBackEntry
                              bytes: self maxNumCallBack * self slotSize
                              flag: 0.
    LpCodeCallBackEntry := hCodeCallBackEntry * 65536!    !

!CallBack methods !  
registerMessage: aSTMessage parameterTypes: aParameterTypeArray
returnType: aReturnType callingConvention: aCCType
    "Private - Answer an instance of CallBack object for stMessage of
     ccType calling convention."
  | emptySlot argsSize highByte lowByte highWord lowWord aCCInteger aCallbackAddress lpfnProc newDataSelector|

    (emptySlot := self class findEmptySlot) <= 0 ifTrue:[
        self error:'Exceeded maximum CallBack objects'.
        ^nil].

    slotNumber := emptySlot.
    stMessage := aSTMessage.
    typeArray := aParameterTypeArray.
    ccType :=  aCCType.
    aCCInteger := CallingConventions at: aCCType.
    CallBackTable at: emptySlot put: self.
    argsSize := self argsSize.

    "Currently, returnType is not needed.  Currently, CallBack object
        returns a double word to the caller.  The caller can then choose
        to either assume the return type is a word or double word."
    returnType := aReturnType.

    "new code "
    newDataSelector := KernelLibrary
                       allocSelector: LpCodeCallBackEntry // 65536.
    newDataSelector := KernelLibrary
                       prestoChangoSelector: LpCodeCallBackEntry // 65536
                       destinationSelector: newDataSelector.
    LpDataCallBackEntry := newDataSelector * 65536.
    "end new code "

    aCallbackAddress := WinAddress fromInteger:
           (LpDataCallBackEntry + ((slotNumber - 1) * self class slotSize)).

    lowByte := SmalltalkSystemWindow handle asInteger \\ 256.
    highByte := SmalltalkSystemWindow handle asInteger // 256.
    aCallbackAddress at: 1 put: 16r68.          "SmalltalkSystemWindow handle"
    aCallbackAddress at: 2 put: lowByte.
    aCallbackAddress at: 3 put: highByte.

    lowByte := emptySlot \\ 256.
    highByte := emptySlot // 256.
    aCallbackAddress at: 4 put: 16r68.          "Push Slot #"
    aCallbackAddress at: 5 put: lowByte.
    aCallbackAddress at: 6 put: highByte.

    lowByte := aCCInteger \\ 256.
    highByte := aCCInteger // 256.
    aCallbackAddress at: 7 put: 16r68.          "Push Calling convention"
    aCallbackAddress at: 8 put: lowByte.
    aCallbackAddress at: 9 put: highByte.

    lowByte := argsSize \\ 256.
    highByte := argsSize // 256.
    aCallbackAddress at: 10 put: 16r68.          "Push size of arguement"
    aCallbackAddress at: 11 put: lowByte.
    aCallbackAddress at: 12 put: highByte.

    highWord := LpfnSTCallBack highHalf.
    lowWord := LpfnSTCallBack lowHalf.
    highByte := lowWord // 256.
    lowByte := lowWord \\ 256.
    aCallbackAddress at: 13 put: 16rEA.          "Jump to STCallBack"
    aCallbackAddress at: 14 put: lowByte.
    aCallbackAddress at: 15 put: highByte.
    highByte := highWord // 256.
    lowByte := highWord \\ 256.
    aCallbackAddress at: 16 put: lowByte.
    aCallbackAddress at: 17 put: highByte.
    KernelLibrary freeSelector: newDataSelector.

    lpfnProc := WinAddress fromInteger:
             (LpCodeCallBackEntry + ((slotNumber - 1) * self class slotSize)).
    lpfnInstanceProc :=
            WinAddress fromString:(
                KernelLibrary
                    makeProcInstance: lpfnProc asParameter
                    withInstance: WIN hInstanceExe).

    ^self! !

!CheckBox class methods !
auto
        "Create an instance of an auto check box."
    ^self new autoCheckBox; yourself!   
nonAuto
        "Create an instance of a non-auto check box."
    ^self new checkBox; yourself!   !

!ClassReader methods !   
fileOut: aFileName
        "Write the source for the class (including the class definition,
         instance methods, and class methods) in chunk file format
         to aFileName."

    | aFileStream aMetaClass |
    class isNil ifTrue: [^self].
    aFileName isNil ifTrue: [^self].
    CursorManager execute change.
    aFileStream := File newFile: aFileName.
    aFileStream lineDelimiter: Cr.
    class fileOutOn: aFileStream.
    aFileStream nextChunkPut: ''.
    aMetaClass := class class.
    aMetaClass instanceVariableString = ''
        ifFalse: [
            aFileStream cr; cr.
            aMetaClass fileOutOn: aFileStream.
            aFileStream nextChunkPut: ''].
    (ClassReader forClass: class class) fileOutOn: aFileStream.
    self fileOutOn: aFileStream.
    aFileStream close.
    CursorManager normal change! !

!Collection methods !
removeAll
        "Answer aCollection.  Remove all the elements
         contained in the receiver collection."

    self shallowCopy do: [ :element | self remove: element].!  !

!ComboBox class methods !
dropDown
        "Answer an instance of a drop down combobox."
    ^self new dropDown; yourself!
dropDownList
        "Answer an instance of a dropdown list combobox."
    ^self new dropDownList; yourself!
simple
        "Answer an instance of a simple combobox."
    ^self new simpleList; yourself! !

!Context methods !   
evaluate
        "Answer the result of evaluating the receiver."

    ^self value! 
evaluateFor: anObject
        "Evaluate the receiver, passing anObject as the evaluation argument."
    ^self evaluateWithArguments: ( Array with: anObject )!  
evaluateWithArguments: argumentArray
        "Evaluate the receiver with the elements of the <argumentArray>
        as the argument values. Error Conditions: If the number of
        arguments required by the receiver is different from the size
        of the argument array, send the message #invalidArgumentCount:
        to the receiver with the number of arguments provided as the
        argument."
    | arraySize |
    arraySize := argumentArray size.
    arraySize = 0 ifTrue: [ ^self value ].
    arraySize = 1 ifTrue: [ ^self value: (argumentArray at: 1) ].
    arraySize = 2 ifTrue: [ ^self value: (argumentArray at: 1) value: (argumentArray at: 2) ].
    ^self invalidArgumentCount: arraySize!
evaluateWithoutInterrupts
        "Disable interrupts, evaluate the receiver, enable interrupts, and
        answer the result of the evaluation."
    | int value |
    int := Process enableInterrupts: false.
    value := self value.
    Process enableInterrupts: int.
    ^value!   
invalidArgumentCount: argCount
        "Private - display an error message indicating that the
         receiver does not support the given number of arguments."
    ^self error: self class printString,
        ' expected ', self numberOfArguments printString,
                ' arguments instead of ', argCount printString! 
numberOfArguments
        "Answer the argument count for the receiver."
    ^blockArgumentCount!
receiver
        "Answer the receiver of the message that created the receiver."
    ^self homeContext receiver!
validateNumberOfArguments: anInteger
        "Private - indicate an error if anInteger is an inappropriate
         number of arguments for the receiver."
    anInteger ~= self numberOfArguments
        ifTrue: [ self invalidArgumentCount: anInteger ].! 
value
        "Answer the result of evaluating the no argument
         block described by the receiver."
    <primitive: 79>
    self validateNumberOfArguments: 0.
    ^self value!
value: anObject
        "Answer the result of evaluating the one argument
         block described by the receiver."
    <primitive: 80>
    self validateNumberOfArguments: 1.
    ^self value: anObject!   
value: arg1 value: arg2
        "Answer the result of evaluating the two argument
         block described by the receiver."
    <primitive: 81>
    self validateNumberOfArguments: 2.
    self primitiveFailed!  !

!CursorManager methods ! 
displayAt: aPoint with: aPen
        "Display the receiver through aPen at the given location."

    UserLibrary
        drawIcon: aPen handle
        x: aPoint x
        y: aPoint y
        hIcon: self handle.!
isCursor
        "Answer true if receiver is a kind of CursorManager."
    ^true! !

!DDEClient class methods !   
singleExecute: application topic: topic commandString: aCommandString
        "Make a single Dynamic Data Exchange request and answer the
         result as a String.  This initiates a conversation, sends
         the request, waits for the response, and terminates the
         conversation.  Answer true if successful, otherwise false."
    | dde result |
    ( dde := self newClient: nil application: application topic: topic ) isNil
        ifTrue: [ ^false ].
    result := dde executeCommand: aCommandString.
    dde terminate.
    ^result!  
singlePoke: application topic: topic item: item data: data
        "Send a single DDE execute.  This initiates a
         conversation, sends the command, and terminates
         the conversation.  Answer true if successful, otherwise false"
    | dde result |
    ( dde := self newClient: nil application: application topic: topic ) isNil
        ifTrue: [ ^false ].
    result := dde pokeItem: item object: data.
    dde terminate.
    ^result! !

!Debugger methods !  
accept: textPane
    "Private - Compile and evaluate the code in textPane.
     Replace the selected temporary variable with
     the result of the evaluation."
    | result context aString tempIndex |
    aString := textPane contents.
    result := Compiler
        evaluate: aString
        in: object class
        to: object
        notifying: textPane
        ifFail: [^textPane modified: true].
    Smalltalk logEvaluate: aString.
    instIndex = 1
        ifTrue: [^textPane modified: false].
    process tempAt: walkbackIndex
        number: instList size - instIndex + 1 put: result.
    self changed: #instance:.
    textPane modified: false!  !

!DialogBox methods ! 
add: aString toComboBox: itemId
        "Add aString at anInteger to the combo box whose
         id is itemId.  anInteger is either the zero-based
         index of the new item or a constant beginning
         with 'Lit' from the WinConstants pool dictionary."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: CbAddstring
        wparam: 0
        lparamStruct: aString asParameter)) asInteger! 
add: aString toComboBox: itemId at: anInteger
        "Add aString at anInteger to the combo box whose
         id is itemId.  anInteger is either the zero-based
         index of the new item or a constant beginning
         with 'Lit' from the WinConstants pool dictionary."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: CbInsertstring
        wparam: anInteger
        lparamStruct: aString asParameter)) asInteger!
add: aString toListBox: itemId
        "Add aString at anInteger to the list box whose
         id is itemId.  anInteger is either the zero-based
         index of the new item or a constant beginning
         with 'Lit' from the WinConstants pool dictionary."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: LbAddstring
        wparam: 0
        lparamStruct: aString asParameter)) asInteger!   
add: aString toListBox: itemId at: anInteger
        "Add aString at anInteger to the list box whose
         id is itemId.  anInteger is either the zero-based
         index of the new item or a constant beginning
         with 'Lit' from the WinConstants pool dictionary."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: LbInsertstring
        wparam: anInteger
        lparamStruct: aString asParameter)) asInteger!  
deleteAllItemsInComboBox: itemId
        "Delete all the items in the combo box whose id is itemId."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: CbResetcontent
        wparam: 0
        lparam: 0)) asInteger!   
deleteAllItemsInListBox: itemId
        "Delete all the items in the list box whose id is itemId."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: LbResetcontent
        wparam: 0
        lparam: 0)) asInteger! 
hideItem: itemId
        "Hide the item whose id is itemId."
    ^UserLibrary showWindow: (UserLibrary getDlgItem: handle item: itemId)
        command: SwHide!   
queryButton: itemId
        "Answer a boolean indicating the 'checked' state of
         the button whose id is itemId."
    ^(UserLibrary
        isDlgButtonChecked: handle
        buttonID: itemId) = 1! 
querySelectionInComboBox: itemId
        "Answer the selected item in the combo box whose
         id is itemId."
    ^ (WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: CbGetcursel
        wparam: 0
        lparam: 0)) asInteger!   
querySelectionInListBox: itemId
        "Answer the selected item in the list box whose
         id is itemId."
    ^ (WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: LbGetcursel
        wparam: 0
        lparam: 0)) asInteger! 
queryText: text inComboBox: itemId startingAt: startingAt
        "Find the index of text in combo box itemId starting.
          at index startingAt.  Index is 0 relative."
    ^(WinLong fromBytes: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: CbFindstring
        wparam: startingAt
        lparamStruct: text asParameter)) asInteger!  
queryText: text inListBox: itemId startingAt: startingAt
         "Find the index of text in list box itemId starting at.
          index startingAt.  Index is 0 relative."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: LbFindstring
        wparam: startingAt
        lparamStruct: text asParameter)) asInteger!  
queryValue: itemNumber inComboBox: itemId
        "Get the value of itemNumber in the combo box
         whose id is itemId."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg:CbGetitemdata
        wparam: itemNumber
        lparam: 0)) asInteger!  
queryValue: itemNumber inListBox: itemId
        "Get the value of itemNumber in the list box
         whose id is itemId."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: LbGetitemdata
        wparam: itemNumber
        lparam: 0)) asInteger!   
select: itemNumber inComboBox: itemId
        "Select itemNumber in the combo box whose id
            is itemId."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: CbSetcursel
        wparam: itemNumber
        lparam: 0)) asInteger!  
select: itemNumber inListBox: itemId
        "Select itemNumber in the list box whose id is itemId."
   ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: LbSetcursel
        wparam: itemNumber
        lparam: 0)) asInteger!  
setButton: itemId value: aBoolean
        "Set the 'checked' state of a radio button or check box
         to aBoolean."
    ^UserLibrary
        checkDlgButton: handle
        item: itemId
        checkIt: aBoolean asParameter!
setItemText: itemId string: aString
        "Set the text of the item whose id is itemId to aString."
    ^UserLibrary
        setDlgItemText: handle
        item: itemId
        text: aString asParameter!
setSelectEdit: itemId startingAt: startingPos endingAt: endingPos
        "Select all characters in the edit field identified by itemId
        that are within the staringPos and endingPos"
   ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: EmSetsel
        wparam: 0
        lparam: startingPos | (endingPos bitShift: 16))) asInteger!   
setTextLimit: itemId to: anInt
        "Set the text limit for the item whose id is itemId
         to anInt."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: EmLimittext
        wparam: anInt
        lparam: 0)) asInteger!   
setValue: anInteger forItem: itemNumber inComboBox: itemId
        "Set the value of itemNumber to anInteger in the combo box
         whose id is itemId."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: CbSetitemdata
        wparam: itemNumber
        lparam: anInteger)) asInteger!   
setValue: anInteger forItem: itemNumber inListBox: itemId
        "Set the value of itemNumber to anInteger in the list box
         whose id is itemId."
    ^(WinLong fromString: (UserLibrary
        sendDlgItemMessage: handle
        item: itemId
        msg: LbSetitemdata
        wparam: itemNumber
        lparam: anInteger)) asInteger! 
wmHelp: wordInteger with: longInteger
        "Private - Process the Smalltalk help message."
    | focusWindow id name cParent |
    self helpManager isNil ifTrue: [ ^nil ].
    focusWindow := longInteger \\ 65536.

        "get the id of the control; if not a child of the dialog
         (e.g. the entry field in a ComboBox), get its parent"
    ( cParent := UserLibrary getParent: focusWindow ) ~= handle asInteger
        ifTrue: [ focusWindow := cParent ].
    id := UserLibrary getWindowWord: focusWindow index: GwwId.

    wordInteger = MsgfMenu
        ifTrue:[ ^super wmHelp: wordInteger with: longInteger ].
    wordInteger = MsgfDialogbox ifTrue: [
        name := self itemIds at: id ifAbsent: [ nil ].
        self helpManager displayHelp: name ]!   !

!DialogTopPane methods ! 
isDialogTopPane
        "Answer whether the receiver is a kind of DialogTopPane."
    ^true!  !

!Dictionary methods !
addAll: aCollection
        "Add each element of aCollection to the receiver,
        returning the collection of elements that were added."
    aCollection isDictionary
        ifTrue: [ aCollection associationsDo: [ :a | self add: a ] ]
        ifFalse: [ aCollection do: [ :o | self add: o ] ].
    ^aCollection! 
isDictionary
        "Answer true if receiver is an instance of class
         Dictionary or one of its subclasses, else answer false."
    ^true! 
removeAll
        "Answer aCollection.  Remove all the elements
         contained in the receiver collection."

    contents atAllPut: nil.
    elementCount := 0.!   !

!DrawnButton methods !   
disable
        "Disable the receiver control; if the control isn't build yet, save
         the state for disabling when built"
    self isHandleOk ifFalse: [self propertyAt: #disabled put: true].
    ^super disable! 
enable
        "Disable the receiver control; if the control isn't build yet, save
         the state for disabling when built"
    self isHandleOk ifFalse: [self propertyAt: #disabled put: nil].
    ^super enable!
validate
        "Private - Show window contents."
    (self propertyAt: #disabled) notNil
        ifTrue: [self disable].
    self showWindow! !

!DynamicLinkLibrary methods !
close
        "Private - Free the DLL"
    KernelLibrary freeLibrary: self.
    self class clearCachedAddresses! !

!File class methods !
findFileName: fileName
        "Answer the full path of the file named fileName,
        located on the path, or nil if not found."

    | searchDirs nameArray buf actualDir |
    "Directories are searched in this order:
        1. The current directory
        2. The Windows directory
        3. The Windows System directory"
    searchDirs := OrderedCollection new.
    searchDirs add: Disk.
    buf := String new: 160.
    (KernelLibrary getWindowsDirectory: buf length: 160) > 0 ifTrue: [
        searchDirs add: (Directory pathName: buf trimNullTerminator) ].
    buf := String new: 160.
    (KernelLibrary getSystemDirectory: buf length: 160) > 0 ifTrue: [
        searchDirs add: (Directory pathName: buf trimNullTerminator) ].

    searchDirs do: [ :dir |
        nameArray := self splitPath: fileName in: dir.
        (actualDir := Directory new)
            drive: (nameArray at: 1);
            pathName: (nameArray at: 2).
        (actualDir validFile: (nameArray at: 3)) ifTrue: [
            ^File new
                setName: (nameArray at: 3) setDirectory: actualDir;
                pathName ]].
    ^nil!
pathNameReadOnly: aString
        "Answer a read only FileStream with path name aString."
    ^self pathNameReadOnly: aString in: Disk! 
pathNameReadOnly: aString in: aDirectory
        "Answer a read only FileStream for the file named aString
         in aDirectory."

    | anArray |
    anArray := self splitPath: aString in: aDirectory.
    ^(Directory new
        drive: (anArray at: 1);
        pathName: (anArray at: 2))
            fileReadOnly: (anArray at: 3)!  !

!FileHandle class methods !  
setLimit: anInteger
        "Set the maximum number of open file handles
         allowed by the OS for this process; this has no
         effect under NT."

    KernelLibrary setHandleCount: anInteger.
    "MaxHandles := anInteger"! !

!FileStream methods !
asByteFileStreamCopy
        "Answer a copy of the receiver as a byte-oriented (single byte) FileStream."
    ^self copy! !

!Font methods !  
bold: aValue
        "set the bold boolean of the font to aValue."
    aValue notNil ifTrue: [
        aValue
            ifTrue: [ logFont lfWeight: 700 ]      "700 is bold"
            ifFalse: [ logFont lfWeight: 400 ] ].   "400 is normal"
    changed := true! 
fixedWidth
        "Answer true if the font is of fixed
         width, else answer false."
     ^( textMetrics tmPitchAndFamily & 16r01 ) =  0  "Fixed pitch = 0"!  !

!GDIDLL methods !
getDIBits: hdc hBitmap: hBitmap startScan: anInt1 scans: anInt2 bitsStruct: aByteArray bitsInfo: bitmapInfo wUsage: int3
    <api: GetDIBits ushort ushort ushort ushort struct struct ushort short>
    ^self invalidArgument! 
setDIBits: hdc hBitmap: hBitmap startScan: anInt1 scans: anInt2 bitsStruct: aByteArray bitsInfo: bitmapInfo wUsage: int3
    <api: SetDIBits ushort ushort ushort ushort struct struct ushort short>
    ^self invalidArgument! 
setDIBitsToDevice: hdc destX: anInt1 destY: anInt2 width: anInt3 height: anInt4 srcX: anInt5 srcY: anInt6
startScan: anInt7 scans: anInt8 bitsExternal: aByteArray bitsInfo: bitmapInfo wUsage: int3
    <api: SetDIBitsToDevice ulong long long ulong ulong long long ulong ulong ulong struct ulong long>
    ^self invalidArgument! 
setDIBitsToDevice: hdc destX: anInt1 destY: anInt2 width: anInt3 height: anInt4 srcX: anInt5 srcY: anInt6
startScan: anInt7 scans: anInt8 bitsStruct: aByteArray bitsInfo: bitmapInfo wUsage: int3
    <api: SetDIBitsToDevice ulong long long ulong ulong long long ulong ulong struct struct ulong long>
    ^self invalidArgument!  
setStretchBltMode: hDC mode: anInt
    <api: SetStretchBltMode  ulong ulong long>
    ^self invalidArgument!
stretchDIBits: hDC xDest: anInt1 yDest: anInt2 cxDest: anInt3 cyDest: anInt4 xSrc: anInt5 ySrc: anInt6 cxSrc: anInt7 cySrc: anInt8 bits: bits bmi: bmi colorUse: anInt9 rop:rop
    <api: StretchDIBits ushort short short short short short short short short ulong struct ushort ulong short>
    ^self invalidArgument!  
textOut: aDeviceContext x: anInteger1 y: anInteger2 textPtr: aStringZ length: anInteger3
    <api: TextOut ushort short short ulong short boolean>
    ^self invalidArgument!   
updateColors: hdc
    <api: UpdateColors ushort short>
    ^self invalidArgument! !

!GraphicsMedium methods !
graphicsTool
        "Answer the graphics tool associated with
         the receiver."
    ^graphicsTool!  
pen: aGraphicsTool
        "Set the graphicsTool for the receiver to aGraphicsTool."
    self graphicsTool: aGraphicsTool!    !

!GraphicsTool class methods !
for: aDeviceContext medium: aGraphicsMedium
        "Answer a new instance of the receiver
         with aDeviceContext and associated with
         aGraphicsMedium."
    ^self forDC: aDeviceContext medium: aGraphicsMedium! !

!GraphicsTool methods !  
isGraphicsTool
        "Answer whether the receiver is an instance of
        GraphicsTool or one of its subclasses."
    ^true!   
releaseAllObjects
        "Private - Deselect all objects and delete the
         Pen and Brush objects."
    self selectObject: (DefaultObjects at: 'Pen').
    "logicalTool notNil ifTrue: [logicalTool initHandle]."
    self selectObject: (DefaultObjects at: 'Brush').
    self selectObject: (DefaultObjects at: 'Bitmap').
    self selectObject: (DefaultObjects at: 'Font')! 
setStretchBltMode: mode

    GDILibrary setStretchBltMode: self handle mode: mode.!   !

!GraphPane methods ! 
graphicsToolClass
        "Private - Answer the graphics tool class used by the receiver."
    ^RecordingPen!   
isGraphPane
        "Answer whether the receiver is an instance of
        GraphPane or one of its subclasses."
    ^true!   !

!GroupBox methods !  
isTransparent
        "Private - answer whether the receiver's background
        should be painted with the same background color
        as its parent pane."
    ^true!  !

!HomeContext methods !   
isHomeContext
        "Answer true if receiver is an instance of class
        HomeContext or one of its subclasses, else answer
        false."
    ^true!   
receiver
        "Answer the receiver of the message that created the receiver."
    ^receiver!   !

!Icon methods !  
createIcon
    "Modified by OSI - Included Digitalk's changes"
        "Private - Create a WINDOWS icon from the receiver."
    | temp bitsPixel planes bitCount |
    readOnly ifTrue:[ ^self ].
    bitsPixel := GDILibrary getDeviceCaps: Display pen handle
        index: Bitspixel.
    planes := GDILibrary getDeviceCaps: Display deviceContext
        index: Planes.
    bitCount := bitsPixel * planes.
    bitCount = xorMask bitCount
        ifTrue: [temp := xorMask]
        ifFalse: [                "create a bitmap compatible with the device."
            temp := Bitmap width: xorMask width height: xorMask height planes: 1 bitCount: bitCount.
            temp pen copyBitmap: xorMask
                from: xorMask boundingBox
                at: 0@ 0 ].

    hIcon := UserLibrary createIcon: WIN hInstance
        width: self extent x
        height: self extent y
        planes: temp planes
        bitsPixel: temp bitCount
        andBits: andMask getDDBits
        xorBits: temp getDDBits.
    hIcon = 0 ifTrue: [ ^self osError ].
    IconHandleTable at: hIcon put: self.
    bitCount = xorMask bitCount ifFalse: [ temp release ]!  
isIcon
        "Answer whether the receiver is a kind of Icon."
    ^true!    !

!IndexedCollection methods ! 
findFirst: aBlock ifAbsent: errorBlock
        "Answer the index of the first element of the
         receiver that causes aBlock to evaluate to true
         (with that element as the argument).  If no such
         element is found, evaluate the argument block."
    | index size |
    size := self size.
    index := 1.
    [index <= size]
        whileTrue: [
            (aBlock value: (self at: index) )
                ifTrue: [^index].
            index := index + 1].
    ^errorBlock value!  
findLast: aBlock ifAbsent: notFoundBlock
        "Answer the index of the last element of the
         receiver that causes aBlock to evaluate to true
         (with that element as the argument).  If no such
         element is found, evaluate notFoundBlock."
    | index size answer |
    size := self size.
    index := 1.
    [index <= size]
        whileTrue: [
            (aBlock value: (self at: index) )
                ifTrue: [answer := index].
            index := index + 1].
    ^answer isNil
        ifTrue: [ notFoundBlock value ]
        ifFalse: [ answer ]!  !

!Integer methods !   
printOn: aStream base: anInteger
        "Append the ASCII representation of
         the receiver with radix b to aStream."
    ^self printOn: aStream base: anInteger showRadix: true!   
printOn: aStream base: anInteger showRadix: aBoolean
        "Append the ASCII representation of
         the receiver with radix b to aStream;
         if aBoolean is true, include the radix
         prefix."
    | aString tempStream n |
    ( n := self ) negative
        ifTrue: [
            aStream nextPut: $-.
            n := self negated ].
    ( anInteger = 10 or: [ aBoolean not ] )
        ifFalse: [ "print radix"
            anInteger printOn: aStream base: 10 showRadix: false.
            aStream nextPut: $r ].
    aString := String new: 16.
    tempStream := WriteStream on: aString.
    [ anInteger <= n ]
        whileTrue: [
            tempStream nextPut: ( Character digitValue: n \\ anInteger ).
            n := n // anInteger ].
    aStream nextPut: ( Character digitValue: n ).
    n := tempStream position.
    aString := tempStream contents.
    [ n = 0 ]
        whileFalse: [
            aStream nextPut: ( aString at: n ).
            n := n - 1 ]!
printPaddedTo: anInteger
        "Answer the string containing the ASCII
         representation of the receiver padded
         on the left with blanks to be at least
         anInteger characters."
    ^self printPaddedWith: $ to: anInteger base: 10! 
printPaddedWith: aCharacter to: anInteger base: aRadix
        "Answer the string containing the ASCII
         representation of the receiver padded
         on the left with aCharacter to be at least
         anInteger characters."
    | aStream padding digits|
    aStream := WriteStream on: (String new: 10).
    self printOn: aStream base: aRadix showRadix: false.
    digits := aStream contents.
    padding := anInteger - digits size.
    padding > 0
        ifTrue: [
            padding := ((String new: padding)
                atAllPut: aCharacter ;
                yourself)]
        ifFalse:[padding := ''].
    ^padding, digits!
printStringRadix: radix
        "Answer a string containing a textual description of the
        receiver with the given <radix>."
    | aStream |
    aStream := WriteStream on: (String new: 16).
    self printOn: aStream base: radix.
    ^aStream contents!   
radix: anInteger showRadix: aBoolean
        "Answer a string which is the ASCII representation
         of the receiver with radix anInteger;
         if aBoolean is true, include the radix prefix."
    | aStream |
    #addedByOriel.
    #fromVWin32.
    aStream := WriteStream on: (String new: 16).
    self printOn: aStream base: anInteger showRadix: aBoolean.
    ^aStream contents! !

!KernelDLL methods ! 
getSystemDirectory: buffer length: anInteger
     <api: GetSystemDirectory struct short ushort>
     ^self invalidArgument! 
getWindowsDirectory: aWinAddressOrString length: anInteger
    aWinAddressOrString isString
        ifTrue: [ ^self getWindowsDirectoryStruct: aWinAddressOrString length: anInteger ]
        ifFalse: [ ^self getWindowsDirectoryAddr: aWinAddressOrString length: anInteger ].! 
getWindowsDirectoryAddr: aWinAddress length: anInteger
     <api: GetWindowsDirectory ulong short ushort>
     ^self invalidArgument!   
getWindowsDirectoryStruct: buffer length: anInteger
     <api: GetWindowsDirectory struct short ushort>
     ^self invalidArgument! 
readFile: handle
        externalBuffer: externalBuffer
        bytesToRead: anInteger
        bytesRead: aWinLong
        overlapped: overlapped
    "Execute the WIN32 read file function where the data is to 
    be copied to an externalBuffer "
    <api: ReadFile ulong ulong ulong struct struct boolean>
    ^self invalidArgument! 
setHandleCount: anInteger
    <api: SetHandleCount ushort ushort> 
    ^self invalidArgument! !

!ListBox class methods ! 
ownerDraw
        "Answer an instance of the receiver where
         the owner will be notified to draw each item."
    ^self new ownerDrawFixed; yourself!  !

!ListBox methods !   
insertItemInControl: aString
        "Private - Insert a list item into the receiver."
    | str addr result |
    self isHandleOk ifFalse: [^self].
    (aString isString)
        ifTrue: [str := aString]
        ifFalse: [str := aString printString].

    addr := WinAddress copyToNonSmalltalkMemoryZ: str asParameter.
    result := UserLibrary sendMessage: handle
        msg: LbInsertstring
        wparam: 65535
        lparam: addr asParameter.
    ( result := ( WinLong fromAddress: result ) asInteger ) < 0
        ifTrue: [ ^self error: 'List contents exceed Windows limits' ].
    addr free!   
itemHeight
        "Answer the height of a list item."
    | aFont |

    height isNil ifTrue: [
        aFont := self font notNil
            ifTrue: [ self font ]
            ifFalse: [
                parent isDialogTopPane
                    ifTrue: [ SysFont ]
                    ifFalse: [ self defaultFont ] ].
        height := aFont height ].
    ^height!
itemHeight: anInteger
        "Set the height of a list item; only has an effect
        before the receiver window is opened."

    height := anInteger! 
printSelector
        "Answer the selector which is sent to the items in list
        to format for display in the control; default = #printString."

    ^self propertyAt: #printSelector!   
printSelector: aSymbol
        "Set the selector which is sent to the items in list
        to format for display in the control; if none is set, non-String
        objects are sent #printString."

    ^self propertyAt: #printSelector put: aSymbol! 
stringForItem: item
        "Private - Answer a string for the given item (which may be
        either a string or some other object which is converted to
        a string using the current printSelector)."
    | printSelector |
    ^( printSelector := self printSelector ) isNil
        ifTrue: [ item asString ]
        ifFalse: [ printSelector evaluateFor: item ]!  !

!Menu methods !  
disableAll
        "Disable all items for the receiver."
    items do: [:mi |
        mi isMenu ifTrue: [ mi disableAll ].
        self disableItem: mi selector ]!   
enableAll
        "Enable all items for the receiver."
    items do: [:mi |
        mi isMenu ifTrue: [ mi enableAll ].
        self enableItem: mi selector ]!   
popUp
        "Popup the receiver menu at the current mouse
         location, wait for the user to make a selection,
         and answer the selector of the selected item
         or nil if the user selected nothing."
    | aWindow |
    aWindow := Notifier activeMainWindow.
    aWindow isNil
        ifTrue: [aWindow := 
                Notifier windows detect: [:win | win isApplicationWindow]].
    ^self popUpIn: aWindow!   !

!Message class methods ! 
numberOfArgumentsFor: aSelector
        "Answer the number of arguments required by a message whose
        selector is <aSelector>, assuming <aSelector> is a legal
        method selector."
    aSelector first isLetter
        ifTrue: [ ^aSelector occurrencesOf: $: ].
   ( #(
         = ~= == ~~ > >= < <=   " comparison operations "
        + - *  / \\  //                    " arithmetic operations "
       & |                                 " logical operations "
       @ ,                                " miscellaneous "
        ) includes: aSelector asSymbol)
            ifTrue: [^1].
    ^aSelector occurrencesOf: $:!   
receiver: receiver selector: selector arguments: argumentArray
        "Answer an instance of the receiver representing a message
        sent to the <receiver> with the given message <selector>
        and the arguments in the <argumentArray>."
    ^self new
        receiver: receiver
        selector: selector
        arguments: argumentArray!  !

!Message methods !   
collectArguments: evaluationArguments
        "Private - answer the action arguments with which to evaluate
        the receiver, collecting from the <evaluationArguments>
        and the predefined arguments in the receiver. "
    | predefinedArgs |
    predefinedArgs := self arguments.
    ^(evaluationArguments size = predefinedArgs size)
        ifTrue: [evaluationArguments]
        ifFalse:
            [( predefinedArgs isNil
                ifTrue: [ predefinedArgs := Array new: (self class numberOfArgumentsFor: selector) ]
                ifFalse: [predefinedArgs copy] )
                    replaceFrom: 1
                    to: (evaluationArguments size min: predefinedArgs size)
                    with: evaluationArguments
                    startingAt: 1]!   
evaluate
        "Answer the result of sending the message represented by the receiver."
    ^self perform! 
evaluateFor: anObject
        "Evaluate the receiver, passing anObject as the evaluation argument."
    ^self evaluateWithArguments: ( Array with: anObject )!  
evaluateWithArguments: anArray
        "Answer the result of sending the message represented by
        the receiver."
    ^self receiver
        perform: self selector
        withArguments: (self collectArguments: anArray)!  !

!MultipleSelectListBox methods ! 
getSelection
        "Private - Answer the collection of selections."
    | count struct |
    self isHandleOk ifFalse: [ ^OrderedCollection new ].
    count := ( WinStructure fromBytes:
        ( UserLibrary
            sendMessage: handle
            msg: LbGetselcount
            wparam: 0
            lparam: 0 ) ) shortAtOffset: 0.
    count = LbErr ifTrue: [ ^OrderedCollection new ].
    struct := WinStructure new: count * 2.
    count := ( WinStructure fromBytes:
        ( UserLibrary
            sendMessage: handle
            msg: LbGetselitems
            wparam: count
            lparamStruct: struct asParameter ) ) shortAtOffset: 0.
    value := OrderedCollection new: count.
    1 to: count do: [ : i |
        value add:
            ( struct shortAtOffset: ( i - 1 ) * 2 ) + 1 ].
    ^value!
selections
        "Answer indices of the items selected."
    value := self getSelection.
    value isNil ifTrue: [ ^OrderedCollection new ].
    ^value!  !

!NationalLanguageSupport class methods ! 
current
        "Answer the current single instance of the receiver class."

    ^NationalLanguage!
current: aNationalLanguageSupport
        "Private - set the current single instance of the receiver class."

    NationalLanguage := aNationalLanguageSupport!  !

!NotificationManager methods !   
initializeTranscript
        "Private - create a new Transcript window."

    self class transcriptClass initializeTranscript! 
isAltKeyDown
        "Answer whether the ALT key is down."
    ^self isKeyDown: AltKey! 
isButton1Down
        "Answer whether the left mouse button is down."
    ^self isKeyDown: VkLbutton!   
isButton2Down
        "Answer whether the right mouse button is down."
    ^self isKeyDown: VkRbutton!  
isControlKeyDown
        "Answer whether the CTRL key is down."
    ^self isKeyDown: ControlKey!
isEscapeKeyInput: aMessage
        " Answer whether the event aMessage
        is an ESC key input."
    ^aMessage selector = #controlKeyInput:
        and: [ ( aMessage arguments at: 1 ) asInteger = EscapeKey ]!  
isShiftKeyDown
        "Answer whether the SHIFT key is down."
    ^self isKeyDown: ShiftKey!   
peek: remove
        "Private - peek in the message queue to see if
         there is a waiting message; answer true if there
         is, otherwise false.  If remove is true, remove the
         next message from the queue and place it into
         WinMsgNS, and answer true; otherwise, answer
         false."
    | answer |
    answer := UserLibrary
        peekMessage: WinMsgNS asParameter
        hwnd: nil
        min: 0
        max: 0
        remove: remove.
    "Notifier setPeekCount: 0."
    ^answer!   
translateAccelerator: winMsgNS
        "Private -  Translates a system message into accelerator key stroke.
         Answer true if it is an accelerator key stroke, else answer false."
    | aWindow afBits aMenuWindow accelTable
      index hWnd hWndString char childWindow|

    char :=KeyboardLibrary
        mapVirtualKey:
            (((ByteArray new: 1)
                replaceFrom:1
                to: 1
                with: winMsgNS
                startingAt: 9) at: 1)
        mapType: 1.
    hWndString := ((ByteArray new: 2)
        replaceFrom:1
        to: 2
        with: winMsgNS
        startingAt: 1).
    hWnd := ((hWndString at: 2) * 256)
                    + (hWndString at: 1).

    "Is hWnd a Smalltalk window"
    (aWindow := Notifier findRealWindow: hWnd)  notNil ifTrue: [
        childWindow := aWindow.
        aWindow mainWindow isMDIChild | aWindow isMDIClient
            ifTrue:[(self translateMDISysAccel:winMsgNS) ifTrue:[^true]].
        aWindow := aWindow mainWindow.
        (aMenuWindow := aWindow menuWindow) notNil ifTrue: [
            afBits := 0.
            (UserLibrary getKeyState: VkControl) < 0 ifTrue:
                [afBits := afBits + AfControl].
            (UserLibrary getKeyState: VkShift) < 0 ifTrue:
                [afBits := afBits + AfShift].
            (UserLibrary getKeyState: VkMenu) < 0 ifTrue:
                [afBits := afBits + AfAlt].
            "afBits = 0 ifTrue:
                [afBits := nil]."

            ((childWindow accel: char afBits: afBits) = true) ifTrue: [
                ^true
            ].
            ((aWindow accel: char afBits: afBits) = true) ifTrue: [
                ^true
            ].

            "If Control-Break then halt."
            afBits = AfControl ifTrue: [
                char = 145  ifTrue: [
                    Process interrupt: 2.
                    ^true]].

            (accelTable := aMenuWindow accelTable) notNil ifTrue: [
                (index := accelTable at:
                              (Array with: char with: afBits) ifAbsent:[nil] )
                    notNil ifTrue: [
                         aMenuWindow sendInputEvent: #performMenuItem:
                                               with: index.
                         ^true]]]].
    ^false!   !

!Number methods !
asPoint
        "Answer a Point containing the receiver as its x and y components."

    ^self @ self!   !

!Object methods !
displayAt: aPoint
        "Display the receiver at aPoint with the Display pen."
    self displayAt: aPoint with: Display pen!  
displayAt: aPoint with: aPen
        "Display the receiver using aPen at the given
         location; by default, use the printString of the
         receiver for display."
    aPen displayText: self printString at: aPoint!   
displayWith: aPen
        "Display the receiver through aPen."
    self displayAt: 0@0 with: aPen.! 
evaluate
        "Answer the result of evaluating the receiver, or the receiver itself if
        it does not have any execution semantics."
    ^self!
evaluateWithArguments: anArray
        "Answer the result of evaluating the receiver, or the receiver itself if
        it does not have any execution semantics."
    ^self!  
isApplicationWindow
        "Answer true if receiver is a kind of ApplicationWindow."
    ^false!   
isCursor
        "Answer true if receiver is a kind of CursorManager."
    ^false!  
isDialogTopPane
        "Answer whether the receiver is a kind of DialogTopPane."
    ^false!   
isDictionary
        "Answer true if receiver is an instance of class
         Dictionary or one of its subclasses, else answer false."
    ^false!
isGraphicsTool
        "Answer whether the receiver is an instance of
        GraphicsTool or one of its subclasses."
    ^false!  
isGraphPane
        "Answer whether the receiver is an instance of
        GraphPane or one of its subclasses."
    ^false!
isHomeContext
        "Answer true if receiver is an instance of class
        HomeContext or one of its subclasses, else answer
        false."
    ^false!  
isIcon
        "Answer whether the receiver is a kind of Icon."
    ^false! 
isMemberOf: aClass
        "Answer true if the receiver is an instance
         of aClass, else answer false."
    ^self class == aClass!  
isStoredPicture
        "Answer whether the receiver is an instance of
        StoredPicture or one of its subclasses."
    ^false!
isWinHandle
        "Answer whether the receiver is an instance of
        WinHandle or one of its subclasses."
    ^false!
objectDeepCopy
        "Answer a copy of the receiver with shallow
         copies of each instance variable."
    | copy aClass instanceVars |
    aClass := self class.
    aClass isVariable
        ifTrue: [
            instanceVars := self basicSize.
            copy := aClass basicNew: instanceVars]
        ifFalse: [
            instanceVars := 0.
            copy := aClass basicNew].
    aClass isPointers
        ifTrue: [
            1 to: instanceVars + aClass instSize do: [ :index |
                copy instVarAt: index
                    put: (self instVarAt: index) copy]]
        ifFalse: [
            1 to: instanceVars do: [ :index |
                copy basicAt: index
                    put: (self basicAt: index)]].
    ^copy! 
objectShallowCopy
        "Answer a copy of the receiver which shares
         the receiver instance variables."
    | answer aClass size |
    aClass := self class.
    aClass isVariable
        ifTrue: [
            size := self basicSize.
            answer := aClass basicNew: size]
        ifFalse: [
            size := 0.
            answer := aClass basicNew].
    aClass isPointers
        ifTrue: [
            1 to: size + aClass instSize do: [ :index |
                answer instVarAt: index
                    put: (self instVarAt: index)]]
        ifFalse: [
            1 to: size do: [ :index |
                answer basicAt: index
                    put: (self basicAt: index)]].
    ^answer!
osError
        "Create a walkback window describing an error condition
        that was returned from the host operating system.  Ask
        the operating system for the last error that occurred.

        Since Smalltalk Express does not support GetLastError(), we use a
        generic error code."

    ^self osError: -1! 
osError: anInteger
        "Create a walkback window describing an error condition
        that was returned from the host operating system, as
        indicated by anInteger"

    | msg |
    msg := 'Operating System Error: ', ( self osErrorMessage: anInteger ).
    ^"Error signal:" self error: msg!  
osErrorMessage: anInteger
        "Private - answer a String which contains the given error number
        and an appropriate error description."

    | msg description |
    msg := anInteger printString.
    ( description := OSErrorDescriptions at: anInteger ifAbsent: [ nil ] ) notNil
        ifTrue: [ msg := msg, ' ( ', description, ' )' ].
    ^msg!
osNotification
        "Create a notification for the informational warning indicated by
        the host operating system.  Ask the host operating system for
        the last error code.

        Since Smalltalk Express does not support GetLastError(), we use a
        generic error code."

    ^self osNotification: -1!
osNotification: anInteger
        "Create a notification for the informational warning #anInteger
        raised by the last API call."

    | msg |
    msg := 'Operating System Notification: ', ( self osErrorMessage: anInteger ).
    ^"Notification signal:" self error: msg! 
osWarning
        "Create a notification for the warning indicated by the host operating
        system.  Ask the host operating system for the last error that occurred.

        Since Smalltalk Express does not support GetLastError(), we use a
        generic error code."

    ^self osWarning: -1!
osWarning: anInteger
        "Create a notification for the warning #anInteger raised by
        the last API call."

    | msg |
    msg := 'Operating System Warning: ', ( self osErrorMessage: anInteger ).
    ^"LoggedWarning signal:" self error: msg!
storeOn: aStream
        "Append the ASCII representation of the
         receiver to aStream from which the
         receiver can be reinstantiated."
    | aClass noneYet |
    (RecursiveSet includes: self)
        ifTrue: [
            RecursiveSet := Set new.
            ^self error:
                'recursive storeOn: not allowed in Object'].
    RecursiveSet add: self.
    aClass := self class.
    aStream
        nextPutAll: '((';
        nextPutAll: aClass name;
        nextPutAll: ' basicNew'.
    aClass isVariable
        ifTrue: [
            aStream nextPut: $:.
            self basicSize printOn: aStream].
    aStream nextPut: $).
    noneYet := true.
    1 to: aClass instSize + self basicSize do: [ :index |
        noneYet
            ifTrue: [noneYet := false].
        aStream nextPutAll: 'instVarAt:'.
        index printOn: aStream.
        aStream nextPutAll: ' put:'.
        (self instVarAt: index) storeOn: aStream.
        aStream nextPut: $;].
    noneYet
        ifFalse: [aStream nextPutAll: 'yourself'].
    aStream nextPut: $).
    RecursiveSet remove: self ifAbsent: []!   !

!OrderedCollection methods ! 
asOrderedCollection
        "Answer an OrderedCollection containing
         the elements of the receiver."

    ^self! !

!Pattern methods !   
match: aCollection index: anInteger
        "Answer a Point representing the start and
         stop of the subcollection within aCollection
         that matches the receiver starting at index
         position anInteger.  Answer nil if no match."
    ^self match: aCollection index: anInteger
        each: [:x | x]!  
match: aCollection index: anInteger each: aOneArgumentBlock
        "Answer a Point representing the start and
         stop of the subcollection within aCollection
         that matches the receiver starting at index
         position anInteger.  Evaluate aOneArgumentBlock
         for each element of aCollection.  Answer nil if no match."
    | firstChar index |
    input size = 0 ifTrue: [^nil].
    state := 1.
    firstChar := input at: 1.
    index := anInteger.
    [true] whileTrue: [
        index > aCollection size ifTrue: [^nil].
        (aOneArgumentBlock value: (aCollection at: index)) = firstChar  ifTrue: [
            state := state + 1.
            [state > input size
                ifTrue: [^index + 1 - input size @ index].
             (index := index + 1) > aCollection size
                ifTrue: [^nil].
             (input at: state) = (aOneArgumentBlock value: (aCollection at: index))
                ifTrue: [
                    state := state + 1]
                ifFalse: [
                    state := (self failAt: state with:
                        (aCollection at: index))].
             state = 1]
                whileFalse: []].
        index := index + 1]!
matchBackward: aCollection index: anInteger
        "Answer a Point representing the start and
         stop of the subcollection within aCollection
         that matches the receiver starting at index
         position anInteger.  Answer nil if no match."
    ^self matchBackward: aCollection index: anInteger
        each: [:x | x]!  
matchBackward: aCollection index: anInteger each: aOneArgumentBlock
        "Answer a Point representing the start and
         stop of the subcollection within aCollection
         that matches the receiver starting at index
         position anInteger.  Evaluate aOneArgumentBlock
         for each element of aCollection.  Answer nil if no match."
    | lastChar index inputSize |
    (inputSize := input size) = 0 ifTrue: [^nil].
    state := inputSize.
    lastChar := input at: inputSize.
    index := anInteger.
    [index > 0] whileTrue: [
        (aOneArgumentBlock value: (aCollection at: index)) = lastChar ifTrue: [
            state := state - 1.
            [state < 1
                ifTrue: [^index @ (index + inputSize - 1)].
             (index := index - 1) < 1
                ifTrue: [^nil].
             (input at: state) = (aOneArgumentBlock value: (aCollection at: index))
                ifTrue: [
                    state := state - 1]
                ifFalse: [
                    state := inputSize].
             state ~= inputSize]
                whileTrue: []].
        index := index - 1].
    ^nil!    !

!Point methods ! 
asPoint
        "Answer the receiver."
    ^self!   
deviceToLogical: aPen
        "Answer a new Point which is the receiver mapped from device
         to logical units."

    ^self dpToLp: aPen handle!  !

!Printer methods !   
startPrintJob
        "Start a print job.  Everything drawn between startPrintJob
         and endPrintJob will become one entry in the print queue."
    ^self startPrintJob: WindowLabelPrefix!  
startPrintJob: aString
        "Start a print job, using aString as the job title; everything
         drawn between startPrintJob and endPrintJob will become
         one entry in the print queue."
    abort := false.
    self setAbortProc;
        escape: Startdoc inputData: aString!    !

!Process class methods ! 
argumentOffset
          "Private"
          ^5!  !

!Process methods !   
argAt: frameIndex number: argNumber 
          "Private - Answer arg argNumber from 
          stack frame at frameIndex." 
          | context method argCount | 
          method := self methodAt: frameIndex. 
          argCount:= method argumentCount. 
          (argNumber > argCount) 
          ifTrue: [self error: 'argNumber too big: ' 
          ,argNumber printString]. 
          (context := self contextFor: frameIndex) isNil 
          ifTrue: [ "access from stack" 
          ^self frameAt: frameIndex 
          offset: (Process argumentOffset + (argCount - argNumber))] 
          ifFalse: [ "access from context" 
          ^context at: ((argCount - argNumber + 1) + method 
          tempCount)].!  
argAt: frameIndex number: argNumber put: value 
          "Private - Answer arg argNumber from 
          stack frame at frameIndex." 
          | context method argCount | 
          method := self methodAt: frameIndex. 
          argCount:= method argumentCount. 
          (argNumber > argCount) 
          ifTrue: [self error: 'argNumber too big: ' 
          ,argNumber printString]. 
          (context := self contextFor: frameIndex) isNil 
          ifTrue: [ "access from stack" 
          ^self frameAt: frameIndex 
          offset: (Process argumentOffset + (argCount - argNumber)) 
          put: value] 
          ifFalse: [ "access from context" 
          ^context 
          at: ((argCount - argNumber + 1) + method tempCount) 
          put: value].! 
numberOfArgsAt: aFrameIndex 
          "Private - answer the number of arguments for the method at 
          aFrameIndex" 
          ^(self methodAt: aFrameIndex) argumentCount!   !

!ProcessScheduler methods !  
backgroundPriority
        "Answer the priority for background processing."

    ^2!   
clearProcesses
        "Private - discard all processes and make
         the currentProcess the user interface
         process."
    | intState |
    intState := Process enableInterrupts: false.
    readyProcesses := nil.
    readyProcesses := Array new: self topPriority.
    1 to: self topPriority do: [ :index |
        readyProcesses
            at: index
            put: OrderedCollection new ].
    Process enableInterrupts: intState.!  
highPriority
        "Answer the priority for a user process to be run
         at a higher priority than the user interface process."

    ^5!   
idleTaskPriority
        "Answer the priority of the system idle task."

    ^1!   
lowPriority
        "Answer the priority for a user process to be run
         when the user interface process is waiting."

    ^3!  
realTimePriority
        "Answer the priority for real time processing."

    ^6!    !

!RadioButton class methods ! 
auto
        "Create an instance of an auto radio button."
    ^self new autoRadioButton; yourself! 
nonAuto
        "Create an instance of a non-auto radio button."
    ^self new radioButton; yourself! !

!Rectangle methods ! 
asRectangle
        "Answer the receiver."
    ^self!   
deviceToLogical: aPen
        "Answer a new Rectangle which is the receiver mapped from device
         to logical units."
    ^self class
        leftTop: ( leftTop deviceToLogical: aPen )
        rightBottom: ( rightBottom deviceToLogical: aPen )!
mapFromWindow: fromWindow to: toWindow
        "Answer a rectangle which is the receiver converted from
         one window coordinate to another."
    ^(self mapToScreen: fromWindow) mapToWindow: toWindow! 
merge: aRectangle
        "Answer a Rectangle representing the area in
         which the receiver and aRectangle merged together."

    aRectangle isNil
        ifTrue: [ ^self ].
    ^(leftTop leftMostAndHighest: aRectangle leftTop)
        rightBottom: (rightBottom rightMostAndLowest: aRectangle rightBottom)!    !

!Screen methods !
rectangleFromUser
        "Answer a rectangle obtained from the user."
    | point1 point2 origin corner rect aPoint |
    Notifier activeMainWindow captureMouseInput.
    CursorManager crossHair change.
    graphicsTool setRop2: R2Notxorpen.
    Notifier consumeInputUntil: [: event |
        event selector = #button1Down:
            ifTrue: [
                graphicsTool place: (
                    point1 := point2 := Cursor sense)].
        event selector = #button1Move:
            ifTrue: [
                aPoint := Cursor sense.
                point2  ~= aPoint
                    ifTrue: [
                        graphicsTool
                            place: point1;
                            box: point2;
                            place: point1;
                            box: aPoint.
                        point2 := aPoint]].
        event selector = #button1Up:].
    graphicsTool place: point1;
        box: point2.
    graphicsTool setRop2: R2Copypen.
    CursorManager normal change.
    UserLibrary releaseCapture.
    origin := (point1 x min: point2 x) @ (point1 y min: point2 y).
    corner := (point1 x max: point2 x) @ (point1 y max: point2 y).
    ^(origin corner: corner)!  !

!ScrollBar class methods !   
horizontal
        "Answer an instance of a horizontal scrollbar."
    ^self new horizontal; yourself.! 
vertical
        "Answer an instance of a vertical scrollbar."
    ^self new vertical; yourself!  !

!SortedCollection methods !  
asOrderedCollection
        "Answer an OrderedCollection containing
        the elements of the receiver.  Override the
        implementation defined in the superclass
        which optimizes by answering the receiver."

    ^(OrderedCollection new: self size)
        addAll: self;
        yourself! 
deepCopy
        "Answer a copy of the receiver with shallow
         copies of each element."

    | answer |
    answer := self species sortBlock: sortBlock.
    self do: [ :element | answer add: element copy ].
    ^answer!   !

!StaticBox class methods !   
background
        "Answer an instance of a static background rectangle."
    ^self new whiteRect; yourself!
backgroundFrame
        "Answer an instance of a static background frame."
    ^self new whiteFrame; yourself!  
foreground
        "Answer an instance of a static foreground rectangle."
    ^self new blackRectangle; yourself!   
foregroundFrame
        "Answer an instance of a static foreground frame."
    ^self new blackFrame; yourself!  
halfTone
        "Answer an instance of a static halftone rectangle."
    ^self new grayRectangle; yourself!
halfToneFrame
        "Answer an instance of a static halftone frame."
    ^self new grayFrame; yourself! !

!StaticGraphic class methods !   
bitmap
        "Create a new StaticGraphic capable of holding a bitmap as its contents;
         under Windows, there is no static bitmap style, so answer a disabled
         DrawnButton"
    ^DrawnButton new
        disable!
bitmap: aBitmap
        "Answer a new static bitmap control with the referenced bitmap."
    ^self bitmap
        contents: aBitmap!   
icon
        "Answer an instance of StaticGraphic capable of holding an icon
         as its contents; this is the default"
    ^self new!   !

!StaticGraphic methods ! 
contents
        "Answer the value of the receiver"
    ^value! 
contents: anIcon
        "Set the value of the receiver to anIcon"
    anIcon notNil ifTrue: [
        value := anIcon.
        handle isValid ifTrue: [ self setIconHandle: anIcon handle ] ]!   
setIconHandle: anIconHandle
        "Private - set the icon handle in the control window"
    UserLibrary setWindowWord: handle index: 4 word: anIconHandle!
validate
        "Private - create or recreate the pane"
    super validate.
    self contents: value!   !

!StaticText class methods !  
centered
        "Answer an instance of a centered static text control."
    ^self new centered; yourself!  
leftJustified
        "Answer an instance of a left justified static text control."
    ^self new leftJustified; yourself!  
rightJustified
        "Answer an instance of a right justified static text control."
    ^self new rightJustified; yourself! !

!StaticText methods !
isTransparent
        "Private - answer whether the receiver's background
        should be painted with the same background color
        as its parent pane."
    ^true!  !

!Stream class methods !  
crString
        "Answer a carriage return / line feed string."
    ^String with: Cr with: Lf!    !

!String methods !
asArrayOfSubstringsSeparatedBy: aCharacter
        "Answer an array of substrings from the
        receiver.  The receiver is divided into
        substrings by of one or more occurrences
        of aCharacter."
    | aStream answer |
    answer := OrderedCollection new.
    aStream := self asStream.
    [ aStream atEnd ] whileFalse: [
        answer add: ( aStream upTo: aCharacter ) ].
    ^answer asArray!  
fileNameLessPath
        "Answer the unqualified file name of
        the receiver file name (file name and
        extension without drive or directory path)."

    ^((self reversed upTo: $\) upTo: $:) reversed! 
replaceEscapeCharacters
        "Replace any C-style escape sequences
        with their literal character equivalents."
    | inStream outStream char |
    inStream := self asStream.
    outStream := ( self species new ) asStream.
    [ inStream atEnd ] whileFalse: [
        ( char := inStream next ) == $\
            ifTrue: [
                char := inStream next.
                char == $n
                    ifTrue: [ outStream nextPut: Lf ].
                char == $t
                    ifTrue: [ outStream tab ].
                char == $u
                    ifTrue: [ outStream nextPut: $& ].
            ]
            ifFalse: [ outStream nextPut: char ] ].
    ^outStream contents!  
zapCrs
        "Answer a copy of the receiver with all the Cr characters
         removed; Lf characters are unchanged."

    ^self reject: [ :c | c == Cr ]!   !

!StringModel methods !   
appendChar: aCharacter
        "Append aCharacter to the end of the last
         line and inform the text pane to update."
    | origin |
    lines isEmpty ifTrue: [lines add: String new].
    origin := (extent x + 1) @ extent y.
    aCharacter == Lf
        ifTrue: [lines add: String new]
        ifFalse:[
    aCharacter == Tab
        ifTrue: [lines at: lines size put: lines last,
                                        (self tabStringAt: origin x)]
    ifFalse: [
        lines at: lines size put: (lines last copyWith: aCharacter)]].
    extent := self extent.
    lastChild update: (
        TextSelection origin: origin corner: extent)! !

!SubPane methods !   
fontAttribute: aFont
        "Set the font attribute to aFont."
    curFont := aFont!   
isTransparent
        "Private - answer whether the receiver's background
        should be painted with the same background color
        as its parent pane."
    ^false!   
subPaneWithFocus: aSubPane
        "Private - pass the subpane with focus up to parent"
    | mainWindow |
    ( mainWindow := self mainWindow ) ~~ self
        ifTrue: [ mainWindow subPaneWithFocus: aSubPane ]!   
wmKillfocus: wordInteger with: longInteger
        "Private - Process the kill focus message."
    super wmKillfocus: wordInteger with: longInteger.
    self event: #losingFocus.
    ^nil!    !

!Symbol methods !
asParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to a host procedure call."
    ^self asString asParameter!   !

!SystemDictionary methods !  
getGui
        "Private - Answer true if the current environment has a GUI."

    ^true!   
gui
        "Private - answer the gui setting."

    | gui |
    gui := Smalltalk at: #SessionIsGUI ifAbsent: [ nil ].
    gui isNil ifTrue: [ gui := self getGui ].
    ^gui!  
gui: aBoolean
        "Private - set the gui setting to aBoolean."

    Smalltalk at: #SessionIsGUI put: aBoolean.!
isGui
        "Answer whether the system is running with GUI support."

    ^self gui "and: [ self guiLoaded ]"!   
signonDLL
        "Answers the signon DLL's file name embedded in the
         image.  When the Smalltalk runtime application
         ( the image) is executed, the signon DLL specified in
         aString will first be loaded before the application is started
         up."

    | aFile answer string |
    aFile := File pathNameReadOnly: self imageName.
    aFile atEnd
        ifTrue: [ aFile close ]
        ifFalse: [
            aFile position: 16r1212.
            ( aFile next = $S and: [ aFile next = $F ] )
            ifTrue: [
                answer := aFile upTo: ( Character value:0 ).
                aFile close.
                ^answer ]
            ifFalse: [
                aFile close.
                ^self error:
                    'Could not find signon file name signature characters' ] ]!  
version
        "Answer the version number as a string"
    ^'2.03'!  !

!TextPane methods !  
arrowKeyInput: anInt  withKeys: keyArray
        "Private - Process an arrow (cursor movement) key."
    | new farLeft |
    anInt = RightKey ifTrue: [
        selection corner x >= (self endOfLine: selection corner y)
            ifTrue: [new := 0 @ (selection corner y + 1)]
            ifFalse: [new := selection corner + (1 @ 0)]].
    anInt = LeftKey ifTrue: [
        ((selection origin x = 1) and: [selection origin y > 1])
            ifTrue: [new := (self endOfLine: selection origin y - 1)
                                          @ (selection origin y - 1)]
            ifFalse: [(keyArray includes: ShiftKey)
                ifTrue: [new := selection origin - (1 @ 0)]
                ifFalse: [new := selection origin - (2 @ 0)]]].
    anInt = UpKey ifTrue: [
        new := selection origin.
        new y = 1 ifTrue: [^self].
        curFont fixedWidth
            ifFalse: [
                new := selection bitCoordinate: selection origin.
                new := new leftAndUp: (0 @ curFont height).
                new := (self stringCoordinate: new).
                new := new - (1 @ 0)]
            ifTrue: [new := new - (1 @ 1)]].
    anInt = DownKey ifTrue: [
        new := selection corner.
        farLeft := new x = 0.
        new y >= self totalLength ifTrue: [^self].
        curFont fixedWidth
            ifFalse: [
                new := selection bitCoordinate: selection corner.
                new := new rightAndDown: (0 @ curFont height).
                new := (self stringCoordinate: new).
                farLeft ifTrue: [new := new - (1 @ 0)]]
            ifTrue: [new := new + (0 @ 1)]].
    anInt = HomeKey ifTrue: [new := 0 @ selection corner y].
    anInt = EndKey ifTrue: [
        new := (self endOfLine: selection corner y) @ selection corner y].
    (keyArray includes: ShiftKey)
        ifTrue: [
            selection selectTo: (new max: 0 @ 1).
            self hideSelection]
        ifFalse: [self selectAfter: (new max: 0 @ 1)].
    self
        makeSelectionVisible;
        displayChanges;
        showSelection.! 
contents: aString
        "Set the contents of the receiver to aString."
    textHolder string: aString.
    (self isHandleOk and: [self graphicsTool notNil and: [self graphicsTool privateHandle isNil]])
        ifTrue:[self invalidateRect:nil erase:false].
    ^aString!    !

!TextTool methods !  
bell
        "Beep the speaker"

    UserLibrary messageBeep: -1.! 
stringWidthOf: aString at: index
        "Return the width of aString up to index
         when written using the current font."
    | answer str extString size |
    index <= 0
        ifTrue: [ ^0 ].
    index >= aString size
        ifTrue:   [ str := aString ]
        ifFalse: [ str := aString copyFrom: 1 to: index ].
    self font isNil
        ifTrue: [  "if font not set yet, calculate based on default font"
            extString := str asMixedString.
            answer := WinAddress loWordFrom: (GDILibrary
                getTextExtent: self handle
                string: extString asParameter
                size: extString size) ]
        ifFalse: [ answer := self font stringWidth: str withDC: self handle ].
    index > aString size ifTrue: [
        answer := answer + (index - aString size * font spaceWidth)].
    ^answer.!    !

!ThreeStateButton class methods !
auto
        "Create an instance of an auto three state button."
    ^self new autoThreeState; yourself!
nonAuto
        "Create an instance of a non-auto check box."
    ^self new threeState; yourself! !

!Toggle methods !
isTransparent
        "Private - answer whether the receiver's background
        should be painted with the same background color
        as its parent pane."
    ^true!  !

!TopPane methods !   
deferredResizeRectangleFor: aRectangle
        "Private - Answer the rectangle to
        use to resize the receiver to aRectangle
        when drawing is being delayed."

    ^framingBlock value: aRectangle!   !

!UserDLL methods !   
checkMenuItem: hMenu
    item: uItem
    flags: fuFlags

    <api: CheckMenuItem ushort ushort ushort short>
    ^self invalidArgument!  
enableMenuItem: hMenu
    item: uItem
    flags: fuFlags

    <api: EnableMenuItem ushort ushort ushort short>
    ^self invalidArgument!
enumWindows: callback lparam: lparam
    <api: enumWindows ulong long boolean>
    ^self invalidArgument!   
getMenuCheckMarkDimensions
    <api: GetMenuCheckMarkDimensions ulong>
    ^self invalidArgument!   
getWindowPlacement: aWindowHandle placement: aByteArray
    <api: GetWindowPlacement ushort struct boolean>
    ^self invalidArgument!  
redrawWindow: hwnd rectangle: rect region: hrgn redraw: flags
    <api: RedrawWindow ushort struct ushort ushort boolean>
    ^self invalidArgument!  !

!ViewManager methods !   
removeView: aView 
        "Remove aView from the view manager." 
    views remove: aView!    !

!WinAddress methods !
asParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to a host system procedure call."
    ^contents! !

!Window class methods !  
ctl3dEnabled
        "Answer whether the Ctl3dDLL class is present and enabled."
    | ctl3d |
    ctl3d := Smalltalk at: #Ctl3dDLL ifAbsent: [ ^false ].
    ^ctl3d enabled! 
ctl3dIfEnabled
        "Answer the Ctl3dDLL class if present and enabled, otherwise answer nil."

    | ctl3d |
    ctl3d := Smalltalk at: #Ctl3dDLL ifAbsent: [ ^nil ].
    ^ctl3d enabled ifTrue: [ ctl3d ] ifFalse: [ nil ]!    !

!Window methods !
affectsFreeClientArea
    	"Answer whether the receiver reduces the amount of
    	free client area in its parent for the receiver's siblings."
    ^self propertyAt: #affectsFreeClientArea ifAbsent: [ false ]!  
affectsFreeClientArea: aBoolean
    	"Set whether the receiver reduces the amount of
    	free client area in its parent for the receiver's siblings."
    ^self
        propertyAt: #affectsFreeClientArea
        put: ( aBoolean ifTrue: [ true ] ifFalse: [ nil ] )! 
allChildren
        "Private - Answer a collection containing the
         receiver's children, and any nested children
         (children of children, etc.)"
    | collection |
    collection := OrderedCollection new.
    children notNil ifTrue: [
        children do: [ :child |
            collection add: child.
            collection addAll: child allChildren ] ].
    ^collection!  
allChildrenDo: aOneArgumentBlock
        "Private - evaluate aOneArgumentBlock for each of the
        receiver's children, and any nested children (children of children, etc.),
        passing the child as an argument."
    children notNil ifTrue: [
        children do: [ :child |
            aOneArgumentBlock value: child.
            child allChildrenDo: aOneArgumentBlock ] ]! 
children
        "Private - Answer the collection of the receiver's children."
    children isNil ifTrue: [ ^IdentityDictionary new ].
    ^children!  
children: anIdentityDictionary
        "Private - Set the dictionary of the receiver's children."
    children := anIdentityDictionary! 
clearGraphicsTool
        "Private - clear the graphics tool handle."

    graphicsTool notNil ifTrue: [ graphicsTool handle: nil ]!   
cursorWindowPosition
        "Private - Answer the current position of the cursor
         in window coordinates."

    ^Cursor sense mapScreenToClient: self.!   
disableRedraw
        "Disable redrawing of the receiver."
    handle = NullHandle ifFalse: [handle disableRedraw]! 
enableRedraw
        "Allow the receiver to be redrawn."
    handle = NullHandle ifFalse: [handle enableRedraw]!
entireClientArea
    "Answer the entire client area available for children
    relative to origin 0@0"

    ^0 @ 0 extent: self extent!   
fontAttribute: aFont
        "Set the font attribute to aFont."
    self propertyAt: #font put: aFont!  
frameWindow
        "Answer the frame window of the receiver."

    ^self! 
framingBlock
        "Private - Answer the framingBlock for the receiver; reimplemented
        in subclasses (TopPane, SubPane)."

    ^nil! 
framingRectangleFor: aRectangle
        " Private - answer the real rectangle "
    ^self zoomed
        ifTrue: [ aRectangle ]
        ifFalse: [ self framingBlock value: aRectangle ]! 
graphicsToolClass
        "Private - Answer the graphics tool class used by the receiver."
    ^Pen!
hasDescendant: aWindow
        "Answer whether aWindow is a child window of the receiver."

    ^UserLibrary isChild: self handle child: aWindow handle!   
hasFocus
        "Answer true if the receiver currently has the focus."

    ^WindowHandle queryFocus = handle!
invalidateRect: aRectangle erase:aBoolean
        "Invalidate aRectangle area in the receiver
         thus force the area to be repainted.  If aBoolean
         is true then the area is erased before being
         repainted."

    self isHandleOk ifFalse: [ "a 0 handle is interpreted as the desktop window."
        ^self ].
    UserLibrary
        invalidateRect: self asParameter
        rectangle: aRectangle asParameter
        erase: aBoolean  "erase background."!   
isMDISupportPane
        "Answer true if receiver is a support pane for MDI."
    ^false!   
isVisible
        "Answer true if the window is visible"
    self isHandleOk
        ifFalse: [ ^false ].
    ^self visible!  
ownerDrawPen
        "Private - answer the pen to be used for drawing
        owner drawn items."

    ^self graphicsTool!
propertyAt: key ifAbsent: aBlock
        "Answer the value associated with key
        in the properties dictionary; if absent,
        answer the result of evaluating aBlock."
    properties isNil ifTrue: [ ^aBlock value ].
    ^properties at: key ifAbsent: aBlock!   
rectangleAttribute
        "Private - answer the rectangle instance variable of
        the receiver."

    ^rectangle!   
rectangleAttribute: aRectangle
        "Private - set the rectangle instance variable of
        the receiver to aRectangle."

    rectangle := aRectangle!   
redraw
    "Redraw the entire window."

    self isHandleOk ifTrue: [ self invalidateRect: nil ].! 
remove: aPane interestIn: aFacet
        "Private - Do nothing as windows in general do not manage
        dependents."!
searchForDefaultTextPane
        " Private - Answer the text pane that should be
         active when the window is opened."

    ^self allChildren detect: [ :aPane | aPane isTextPane ] ifNone: [ nil ].!   
superWindow
        "Answer the non-frame parent window of the receiver."
    ^self parent! 
visible
        "Answer true if the window is visible"
     ^UserLibrary isWindowVisible: self handle!  
wmSyskeydown: wordInteger with: longInteger
        "Private - Process the system key down message."
    | keyCollection |
        "Trap F9 key to cycle windows when minimized"
    wordInteger = F9Key ifTrue: [^Notifier cycle].

        "Only process alt key oriented sys keys."
    (longInteger bitAnd: 16r20000000) ~= 0
        ifFalse: [^nil].

        "Don't process VK input for which there is a WM_CHAR msg"
    (KeyboardLibrary
        mapVirtualKey: wordInteger
        mapType: 2)  ~= 0
            ifTrue: [^nil].

   keyCollection := OrderedCollection new: 3.
   (UserLibrary getKeyState: VkShift) < 0
        ifTrue: [keyCollection add: ShiftKey] .
   (UserLibrary getKeyState: VkControl) < 0
        ifTrue: [keyCollection add: ControlKey].
    keyCollection add: AltKey.
    self
        sendInputEvent: #virtualKeyInput:withKeys:
        withArgs: (Array with: wordInteger  with: keyCollection).
    ^nil!   !

!WindowHandle methods !  
disableRedraw
        "Private - the receiver should not repaint itself"
    ^self noRedraw: true!  
enableRedraw
        "Private - the receiver should repaint itself"
    ^self noRedraw: false!  
hideWindow
    "Private - make the receiver window
    and all of its children invisible."

    UserLibrary showWindow: self
        command: SwHide!
noRedraw: aBoolean
        "Private - Stop the receiver from
         repainting itself."
    UserLibrary
        sendMessage: self
        msg: WmSetredraw
        wparam: aBoolean not asParameter
        lparam: nil! 
showIconicWindow
    "Private - Activate the receiver window
    and show it as an icon."

    UserLibrary showWindow: self
        command: SwShowminimized!
showMaximizedWindow
    "Private - Activate the receiver window
    and show it maximized."

    UserLibrary showWindow: self
        command: SwShowmaximized!  
showWindow
    "Private - Activate the receiver window
    and show it at its normal size."

    UserLibrary showWindow: self
        command: SwShow! !

!WinHandle class methods !   
nullValue
        "Answer an instance of the receiver class which represents
        an invalid (uninitialized) value."
    ^NullHandle! !

!WinHandle methods ! 
isWinHandle
        "Answer whether the receiver is an instance of
        WinHandle or one of its subclasses."
    ^true!   !

!WinInfo class methods ! 
isWindows95
        "Answer whether this system is running on Windows 95."
    | major |
    ^(major := self windowsMajorVersion) >= 4 or: [
        major = 3 and: [ self windowsMinorVersion >= 95 ]]!    !

!WinLogicalObject methods !  
createObject
        "Private - Create the windows logical object."
    | attrib obj dict |
    attrib := self attributeArray.
    dict := self class anchorDictionary.
    obj := dict at: attrib ifAbsent: [nil].
    obj isNil ifTrue: [

        "Modified by DMZ, OSI 2/1/97 Corrects fundamental bug in Smalltalk Express, where
        attempting to delete GDI objects that are still selected into a DC corrupts Windows'
        GDI subsystem. Since there is no easy way to track which GDI objects are selected,
        for expediency we disable the cache thresholding and flushing code."
        #modifiedByOSI.
        "dict size > self class threshold
            ifTrue: [
                self class deleteObjects:
                    (self class destroyAllHandles)]."

        obj := self.
        dict at: attrib put: self].
    obj privateHandle isNil ifTrue: [
        obj handle: obj getHandle]!    !

!WinLong methods !   
+ aNumber
    ^self class fromInteger: ( self asInteger + aNumber )! 
- anInteger
        "Answer a copy of the receiver with bytes that represent
        the value anInteger less than the receiver."
    ^self class fromInteger: self asInteger - anInteger! 
asUnsignedInteger
        "Answer the receiver as a positive integer."
    ^self uLongAtOffset: 0!  
printOn: aStream
        "Append a text representation of the receiver to aStream."
    aStream nextPutAll: self class name, ': ', self asInteger printString!    !

!WinMessage methods !
scanCode
    ^self byteAtOffset: 8!    !

!WinPoint methods !  
printOn: aStream
        "Append a textual representation of the receiver to aStream."
    aStream nextPutAll: self class name, ' { ', self asPoint printString, ' } '!   !

!WinRectangle methods !  
printOn: aStream
        "Append a textual representation of the receiver to aStream."
    aStream nextPutAll: self class name, ' { ', self asRectangle printString, ' } '! 
xLeft
    ^self shortAtOffset: 0!
xRight
    ^self shortAtOffset: 4!   
yBottom
    ^self shortAtOffset: 6!  
yTop
    ^self shortAtOffset: 2!   !

!WinStructure methods !  
booleanAtOffset: anInteger put: aBoolean
        "Set the value at anInteger in the receiver to aBoolean.
         Offsets are zero relative."
    self uShortAtOffset: anInteger put: aBoolean asParameter!   
floatAtOffset: anInteger
        "Answer the 8-byte floating point value at offset <anInteger> in the receiver.
        Offsets are zero relative."
    | aFloat |
    aFloat := Float new.
    aFloat replaceFrom: 1
        to: aFloat size
        with: self contents
        startingAt: anInteger + 1.
    ^aFloat!
floatAtOffset: anInteger put: aFloat
        "Store the 8-byte floating point value at offset <anInteger> in the receiver.
        Offsets are zero relative."
    self bytesAtOffset: anInteger put: aFloat!    !

!WinTextMetrics methods !
tmDescent
        "Private - Answer the tmDescent field."
    ^self shortAtOffset: 4!   
tmExternalLeading
        "Private - Answer the tmExternalLeading field."
    ^self shortAtOffset: 8! !

!ApplicationWindow methods ! 
initSize
        "Private - Answer the initial size of the receiver."
    | size |
    rectangle notNil ifTrue: [ ^rectangle ].
    size := (owner respondsTo: #initWindowSize)
        ifTrue: [ owner initWindowSize ]
        ifFalse: [ self initWindowSize ].
    ^size isRectangle
        ifTrue: [ size ]
        ifFalse: [
            size isPoint
                ifTrue: [ self boxOfSize: size ]
                ifFalse: [0 @ 0 extent: 100@100 ]].! !

!CursorManager methods ! 
display
        "Display the receiver on the screen; answer the
        hide/show level of the cursor."

    ^self showCursor: true!  
hide
        "Hide the cursor from the screen;
        answer the hide/show level of the cursor."

    ^self showCursor: false!   
setWinCursor
        "Private - Change the current cursor to the shape of the receiver."
    | w defaultCursor |
    handle isNil ifTrue: [
        (w := self class windowUnderCursor) isNil
            ifTrue: [ ^self class setWinCursor: IdcArrow ]
            ifFalse: [
                (defaultCursor := w defaultCursor) notNil
                    ifTrue: [ ^UserLibrary setCursor: defaultCursor handle ]
                    ifFalse:[
                        (defaultCursor := UserLibrary getClassWord: w handle index: GcwHcursor) = 0
                            ifTrue: [ defaultCursor := self class arrow handle ].
                        ^UserLibrary setCursor: defaultCursor ]]].
    handle isWinHandle
        ifTrue: [ ^UserLibrary setCursor: handle ].
    handle isInteger
        ifTrue: [ self class setWinCursor: handle ].!   
showCursor: aBoolean
        "Private - Display the receiver on the screen
         if aBoolean is true else hide it; answer
         the hide/show level of the cursor."

    ^UserLibrary showCursor: aBoolean!  !

!Fraction methods !  
= aNumber
        "Answer true if the receiver is equal
         to aNumber, else answer false."

    aNumber isFloat ifTrue: [ ^aNumber = self ].
    ^aNumber isNumber and:
        [numerator = aNumber numerator and:
            [denominator = aNumber denominator]]!  !

!GraphicsTool methods !  
canvasBox
        "Private - Answer a rectangle which is the total
         drawable area."

    ^graphicsMedium isGraphPane
        ifTrue: [ graphicsMedium scrollingRectangle ]
        ifFalse: [ self boundingBox ]!   
location
        "Answer a Point which represents the current
         position of the pen."
    | answer |
    graphicsMedium isStoredPicture
        ifTrue: [ ^location ].
    answer := WinStructure fromBytes: (GDILibrary getCurrentPosition: self handle).
    ^(answer shortAtOffset: 0) @ (answer shortAtOffset: 2)!  
selectObject: anObject
        "Select anObject into the device context and answer
          the previously selected object."
    | hPrevious |
    anObject isNil
        ifTrue: [ ^nil ]
        ifFalse: [
           self allHandles do: [ :h |
                h notNil ifTrue: [
                    hPrevious := GDILibrary selectObject: h with: anObject ]]].
    graphicsMedium isStoredPicture
        ifTrue: [ ^nil ]
        ifFalse: [ ^hPrevious ]!    !

!Message methods !   
performDeferred
        "Perform the expression by requeueing the request."

    [ DeferredRequests add: self ] evaluateWithoutInterrupts.!  !

!NotificationManager methods !   
add: aWindow
        "Private - Add aWindow to the Notifier so aWindow can
         receive incoming events."
    [ windows at: aWindow handle asInteger put: aWindow ]
        evaluateWithoutInterrupts!
consumeInputUntil: aBlock
        "Consume all input events until aBlock evaluates true.  aBlock takes
         one argument which is the current Message event."
    | e |
    [ CurrentEvents isEmpty ] whileTrue: [ self readWinQueue ].
    [ e := CurrentEvents removeFirst ] evaluateWithoutInterrupts.
    [ aBlock value: e ] whileFalse: [
        [ CurrentEvents isEmpty ] whileTrue: [ self readWinQueue ].
        [ e := CurrentEvents removeFirst ] evaluateWithoutInterrupts ]!   
notify: aWinMessage
    "Private - Translate a host system event into the appropriate
    message sent to the window specified in the event."
    | receiver selector newWindow |

    "If the handle of the event's destination window is not present
    in the windows instance variable, it may be a newly created
    window (getting a WmCreate message)"
    (receiver := self findWindow: aWinMessage hwnd) isNil ifTrue: [
        (newWindow := ApplicationWindow newWindow) notNil ifTrue: [
            receiver := newWindow
                handle: ( WindowHandle fromInteger: aWinMessage hwnd );
                yourself.
            ]].
    selector := self selectorFor: aWinMessage msg.
    (receiver isNil or: [ selector == #unknownWinEvent:with: ])
        ifTrue: [ ^nil ].
    ^receiver
        perform: selector
        withArguments: (Array with: aWinMessage wparam with: aWinMessage lparam)! 
postInputEvent: aMessage
        "Private - Add a Message to CurrentEvents."

    [ CurrentEvents add: aMessage ] evaluateWithoutInterrupts.
    KeyboardSemaphore signal!
remove: aWindow
        "Private - Remove aWindow from the Notifier."

    self removeEventsFor: aWindow.
    [ windows removeKey: aWindow handle asInteger ifAbsent: [ nil ] ]
        evaluateWithoutInterrupts!   
remove: events for: aWindow
        "Private - Remove queued events for aWindow."

    [   CurrentEvents copy do: [ :e |
            ((e receiver == aWindow) and: [ events includes: e selector ])
                ifTrue: [ CurrentEvents remove: e ifAbsent: [ nil ]]].
    ] evaluateWithoutInterrupts.!
removeEventsFor: aWindow
        "Private - Remove queued and deferred events for aWindow."

    [   CurrentEvents copy do: [ :e |
            e receiver == aWindow
                ifTrue: [ CurrentEvents remove: e ifAbsent: [ nil ]]].
        DeferredRequests copy do: [ :e |
            e receiver == aWindow
                ifTrue: [ DeferredRequests remove: e ifAbsent: [ nil ]]].
    ] evaluateWithoutInterrupts.! !

!Pen methods !   
winPointList: anArrayOfPoints
        "Private - answer a WinStructArray containing a list
        of POINT structures corresponding to anArrayOfPoints."
    | winPoints |
    winPoints := anArrayOfPoints collect: [ :p | WinPoint fromPoint: p ].
    ^WinStructArray fromCollection: winPoints!   !

!Process methods !   
terminateWithoutProtection
        "Terminate the receiver without causing protection
        blocks to be executed."

    Processor unschedule: self.
    self == CurrentProcess ifTrue: [ Processor schedule ]!  !

!ProcessScheduler methods !  
readyToRun
        "Answer the receiver's OrderedCollection of ready to run processes."

    ^readyProcesses!  
schedule: process
        "Private - add the <process> to the queue of runnable processes."

    | queue |
    queue := self readyToRun at: process priority.
    queue addLast: process!
terminateActive
        "Terminate the active process."

    Process enableInterrupts: false.
    self suspendActive.!
unschedule: process
        "Private - if the <process> is in the queue of runnable
        processes, remove it."

    | queue |
    queue := self readyToRun at: process priority.
    queue remove: process ifAbsent: []!  !

!SystemDictionary methods !  
closeSignOn
        "Private - Close the sign on screen."
    | signOnLib |
    Smalltalk isRunTime
        ifTrue: [
            signOnLib := SignOnDLL open: Smalltalk signonDLL ]
        ifFalse: [
            signOnLib := SignOnDLL open: 'vwvm20.dll' ].
    (Message new
         receiver: signOnLib
        selector: #closeSignOn
        arguments: (Array new) ) performDeferred.
    (Message new
        receiver: signOnLib
        selector: #free
        arguments: (Array new) ) performDeferred.!  !

!TextTool methods !  
displayText: aString at: aPoint
        "Display aString at aPoint."
    | str strMem stringWidth |
    str := (aString isString)
        ifTrue: [aString]
        ifFalse: [aString printString].
    str size > 8000 ifTrue: [ "size must be < 32k"
        str := (str copyFrom: 1 to: 8000), '...etc...'].
    str := str asMixedString.
    strMem := WinAddress copyToNonSmalltalkMemory: str asAsciiZ.
    self allHandles do: [: h |
        GDILibrary
            textOut: h
            x: aPoint x
            y: aPoint y
            textPtr: strMem asParameter
            length: str size ].
     strMem free.

    "metafile DCs don't support GetTextExtent API"
    self graphicsMedium isStoredPicture
        ifTrue: [ stringWidth := 0 ]
        ifFalse: [ stringWidth := self stringWidthOf: str ].
    self place: ("self location" aPoint right: stringWidth).!    !

!Window methods !
close
        "Private - Close the window."
    |aHandle|
    self stopReceivingMessages.
    (graphicsTool isGraphicsTool) ifTrue: [
        graphicsTool destroy.
        graphicsTool := nil ].
    children size > 0 ifTrue: [
        children do: [ :subpane | subpane close ]].
    self destroy.!
mainWindow
        "Answer the receiver's main window.  For example,
         if the receiver is a subpane, the main window will be an
         instance of TopPane."

    ^parent isWindow
        ifTrue: [ parent mainWindow ]
        ifFalse: [ self ]!   
noRedraw: aBoolean
        "Private - Stop the receiver from
         repainting itself."

    handle noRedraw: aBoolean.!
realInvalidateRect: aRectangle
        "Invalidate aRectangle in the receiver.  Causes the
         window to be repainted."
    UserLibrary
        redrawWindow: self asParameter
        rectangle: aRectangle asParameter
        region: nil
        redraw: RdwInvalidate | RdwAllchildren | RdwUpdatenow!   
sendMouseMoveInputEvent: selector with: argument
        "Private - Add a MessageExpression to CurrentEvents."

    | lastMessage int |
    CurrentEvents isEmpty
        ifTrue: [^self sendInputEvent: selector with: argument].
    int := Process enableInterrupts: false.
    lastMessage := CurrentEvents last.
    ((selector = lastMessage selector)  and:
        [(self = lastMessage receiver)])
            ifTrue:
                [lastMessage arguments: (Array with: argument).
                 CurrentEvents at: CurrentEvents size put: lastMessage]
            ifFalse:
                [self sendInputEvent: selector with: argument].
    "KeyboardSemaphore signal"
    Process enableInterrupts: int.!   
wmPaint: wordInteger with: longInteger
        "Private - Process the paint message."
    | displayContext paintStructure oldDC result |
    self graphicsTool isGraphicsTool ifFalse: [ ^nil ].
    "needed because beginPaint generates wmEraseBkgrnd"
    paintStructure := WinAddress copyToNonSmalltalkMemory: WinPaintStructure new asParameter.
    result := UserLibrary
        beginPaint: self asParameter
        paintStructure: paintStructure asParameter.
    displayContext := DeviceContext fromInteger: result.
    oldDC := graphicsTool privateHandle.
    self graphicsTool setHandle: displayContext.
    self display.
    self graphicsTool handle: oldDC.

    UserLibrary
        endPaint:       self asParameter
        paintStructure: paintStructure asParameter.
    paintStructure unlockAndFree.
    ^1!  !

!WindowHandle methods !  
isValid
        "Private - Answer true if the receiver is a valid window
         handle."

    ^super isValid and: [ UserLibrary isWindow: self ]! !

!WinHandle methods ! 
= aHandle
        "Answer true if the receiver is the same as aHandle."
    aHandle isWinHandle ifFalse: [^false].
    1 to: self size do: [:i | (self at: i) = (aHandle at: i)
        ifFalse: [^false]].
    ^true!   
isValid
        "Answer whether the receiver is a valid (non-NULL)
         handle."

    ^self ~= self class nullValue!    !

!WinStructure methods !  
asParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to a host system procedure call."

    ^contents isString
        ifTrue: [ contents ]        "kludge for old VWin16 structs in os memory"
        ifFalse: [ contents asParameter ]! !

"define class"   

GraphicsMedium subclass: #Bitmap
  instanceVariableNames: 
    'bitmapHandle bitmapInfo archive palette '
  classVariableNames: 
    'MemoryContext OldMemoryContext BitmapHandleTable DefaultBitmap AuxillaryDC DefaultPaletteHandle '
  poolDictionaries: 
    'WinConstants '!

!ApplicationWindow methods ! 
saveImageFile
        "Private - Save the current image and
         log the event on the change log."
    (Sources at: 2) close.
    Disk makeCurrent.
    ^Smalltalk save!   !

!Bitmap class methods !  
aboutToSaveImage
        "Private - clean up unused bitmaps, and save backup
         of all Bitmap instances"
    self purgeUnusedBitmaps.
    self allInstancesPrim do: [ :b | b aboutToSaveImage ].
    OldMemoryContext := MemoryContext!
bitBlt: destDC
    x: x1
    y: y1
    width: srcWidth
    height: srcHeight
    srcDC: srcDC
    xSrc: x2
    ySrc: y2
    rop: aRopConstant
        "Private - Call GDI BitBlt function."
    ( GDILibrary
         bitBlt: destDC
         x: x1
         y: y1
         width: srcWidth
         height: srcHeight
         srcDC: srcDC
         xSrc: x2
         ySrc: y2
         rop: aRopConstant )
            ifFalse: [ ^self osError ]! 
createBitmap: width
    height: height
    planes: planes
    bitCount: bitCount
    bits: bits
        "Private - call the CreateBitmap API."
    | hBitmap |
    ( hBitmap := GDILibrary
        createBitmap: width
        height: height
        planes: planes
        bitCount: bitCount
        bits: bits ) = 0
            ifTrue: [ ^self osError ].
    ^hBitmap!   
createCompatibleDC: aDeviceContext
        "Private - call the CreateCompatibleDC API."
    | hDC |
    ( hDC := GDILibrary createCompatibleDC: aDeviceContext ) = 0
        ifTrue: [ ^self osError ].
    ^hDC!
createDIBitmap: hDC
    bitmapInfo: bitmapInfo
    init: initFlag
    bits: bits
    usage: usageFlag
        "Private - call the CreateDIBitmap API."
    | hBitmap bitmapInfoHeader |
    bitmapInfoHeader := WinBitmapInfoHeader
        width: bitmapInfo width
        height: bitmapInfo height
        planes: bitmapInfo planes
        bitCount: bitmapInfo bitCount.
    ( hBitmap := GDILibrary
        createDIBitmap: hDC
        infoHeader: bitmapInfoHeader asParameter
        dwUsage: initFlag
        initBitsStruct: bits asParameter
        initInfo: bitmapInfo asParameter
        wUsage: usageFlag ) = 0
            ifTrue: [ ^self osError ].
    ^hBitmap!  
createDIBitmap: hDC
    bitmapInfo: bitmapInfo
    init: initFlag
    externalBits: anExternalAddress
    usage: usageFlag
        "Private - call the CreateDIBitmap API."
    | hBitmap bitmapInfoHeader |
    bitmapInfoHeader := WinBitmapInfoHeader
        width: bitmapInfo width
        height: bitmapInfo height
        planes: bitmapInfo planes
        bitCount: bitmapInfo bitCount.
    ( hBitmap := GDILibrary
        createDIBitmap: hDC
        infoHeader: bitmapInfoHeader asParameter
        dwUsage: initFlag
        initBits: anExternalAddress asParameter
        initInfo: bitmapInfo asParameter
        wUsage: usageFlag ) = 0
            ifTrue: [ ^self osError ].
    ^hBitmap!  
fromDLLFile: aFileName name: bitmapName
        "Answer an instance of Bitmap loaded from aModule,
         identified by bitmapName."
    ^self fromModule: aFileName id: bitmapName! 
fromFile: bitmapFile in: dir
        "Answer an instance of Bitmap copied from bitmapFile.
        bitmapFile must be in DIB format with '.bmp' extension."
    ^(DIB fromFile: bitmapFile in: dir) asBitmap!  
fromFileStream: aFileStream
        "Answer an instance of Bitmap read from aFileStream.
        The contents of aFileStream must be in DIB format (as
        that of a file with '.bmp' extension)."
    ^(DIB fromFileStream: aFileStream) asBitmap!   
fromHandle: hBitmap clipWidth: aClipWidth clipHeight: aClipHeight
         "Answer an instance of Bitmap copied from
          bitmap handle hBitmap, Clipped by clipWidth
          and clipHeight."
    | bitmapStruct srcDC newBitmap oldHandle1 oldHandle2 aWidth aHeight|
    srcDC := GDILibrary createCompatibleDC: Display deviceContext.
    oldHandle1 := GDILibrary selectObject: srcDC with: hBitmap.
    GDILibrary
        getObject: hBitmap
        count: WinBitmapStruct sizeInBytes
        lpObject: (bitmapStruct :=  WinBitmapStruct new) asParameter.
    aWidth := aClipWidth isNil
        ifTrue: [ bitmapStruct width ]
        ifFalse: [ bitmapStruct width min: aClipWidth ].
    aHeight := aClipHeight isNil
        ifTrue: [ bitmapStruct height ]
        ifFalse:[ bitmapStruct height min: aClipHeight ].
    bitmapStruct width: aWidth.
    bitmapStruct height: aHeight.
    newBitmap := self new bitmapIndirect: bitmapStruct.
    oldHandle2 := GDILibrary
        selectObject: newBitmap deviceContext
        with: newBitmap handle.
    GDILibrary bitBlt: newBitmap deviceContext
          x: 0
          y: 0
          width: aWidth
          height: aHeight
          srcDC: srcDC
          xSrc: 0
          ySrc: 0
          rop:  Srccopy.
     oldHandle1 ~= 0 ifTrue: [ GDILibrary selectObject: srcDC with: oldHandle1].
     GDILibrary deleteDC: srcDC.
     GDILibrary selectObject: newBitmap deviceContext with: oldHandle2.
     ^newBitmap!  
fromHandle: hBitmap offset: offset extent: extent
        "Answer an instance of Bitmap copied from
        bitmap handle hBitmap, Clipped by clipWidth
        and clipHeight."
    | bitmapStruct srcDC newBitmap oldHandle1 oldHandle2 aWidth aHeight aClipWidth aClipHeight |
    aClipWidth := extent x.
    aClipHeight := extent y.
    srcDC := self createCompatibleDC: Display deviceContext.
    oldHandle1 := GDILibrary selectObject: srcDC with: hBitmap.
    GDILibrary
        getObject: hBitmap
        count: WinBitmapStruct sizeInBytes
        lpObject: ( bitmapStruct := WinBitmapStruct new ) asParameter.
    aWidth := aClipWidth isNil
        ifTrue: [ bitmapStruct width ]
        ifFalse: [ bitmapStruct width min: aClipWidth ].
    aHeight := aClipHeight isNil
        ifTrue: [ bitmapStruct height ]
        ifFalse: [ bitmapStruct height min: aClipHeight ].
    bitmapStruct width: aWidth.
    bitmapStruct height: aHeight.
    newBitmap := self new bitmapIndirect: bitmapStruct.
    oldHandle2 := GDILibrary
        selectObject: newBitmap deviceContext
        with: newBitmap handle.
    self
        bitBlt: newBitmap deviceContext
        x: 0
        y: 0
        width: aWidth
        height: aHeight
        srcDC: srcDC
        xSrc: offset x "- 1"
        ySrc: offset y "- 1"
        rop: Srccopy.
    oldHandle1 ~= 0 ifTrue: [ GDILibrary selectObject: srcDC with: oldHandle1 ].
    GDILibrary deleteDC: srcDC.
    GDILibrary selectObject: newBitmap deviceContext with: oldHandle2.
    ^newBitmap!   
fromModule: aModuleName id:  bitmapName
        "Answer an instance of Bitmap whose id is bitmapName
         contain in the module identified by aModuleName.
         bitmapName may be an integer or a string."
    | handle bitmap |
    "Modified by DMZ, OSI 2/1/97 Note that in VST, this
    method only supports module names as its first argument,
    whereas in Smalltalk Express the first argument is a module handle."
    #modifiedByOSI.
    aModuleName isString ifFalse: [ ^self error: 'Obsolete usage' ].
    ^self new fromModule: aModuleName id: bitmapName!   
initialize
        "Private - Initialize memory device context. This must
         be done at each startUp."
    | hBitmap |
    BitmapHandleTable := Dictionary new.
    MemoryContext := GDILibrary createCompatibleDC: Display deviceContext.
    AuxillaryDC := GDILibrary createCompatibleDC: Display deviceContext.
    hBitmap := self
        createBitmap: 1
        height: 1
        planes: 1
        bitCount: 1
        bits: nil.
    DefaultBitmap := GDILibrary selectObject: MemoryContext with: hBitmap.
    GDILibrary selectObject: MemoryContext with: DefaultBitmap.
    GDILibrary deleteObject: hBitmap.
    DefaultPaletteHandle := GraphicsTool getStockObject: DefaultPalette.
"    Bitmap allInstancesPrim do: [ : each | each restoreBitmap].
    OldMemoryContext := MemoryContext"! 
purgeUnusedBitmaps
        "Private - Purge unused bitmaps from the system."
    | handles all bitmaps |
    all := BitmapHandleTable keys.
    BitmapHandleTable := Dictionary new.
    bitmaps := Bitmap allInstances.
    handles := bitmaps collect: [ :each | each bitmapHandle "handle" ].
    GDILibrary selectObject: MemoryContext with: DefaultBitmap.
    all do: [ :each |
        ( each notNil and: [ ( handles includes: each ) not ] ) ifTrue: [
            GDILibrary deleteObject: each ]].
    bitmaps do: [ :each |
        each bitmapHandle notNil ifTrue: [
            BitmapHandleTable at: each bitmapHandle put: each ] ].!  
readBitmapHeader: bitmapFile
        "Private - Read the bitmap info header structure from a
         bitmapFile. Answer an instance of WinBitmapInfoHeader."
    | bitmapInfo |
    bitmapInfo := WinBitmapInfoHeader new.
    bitmapInfo
        biSize: bitmapFile nextULong;
        width:  bitmapFile nextULong;
        height: bitmapFile nextULong;
        planes: bitmapFile nextUShort;
        bitCount: bitmapFile nextUShort;
        compression: bitmapFile nextULong;
        sizeImage: bitmapFile nextULong;
        xPelsPerMeter: bitmapFile nextULong;
        yPelsPerMeter: bitmapFile nextULong;
        clrUsed: bitmapFile nextULong;
        clrImportant: bitmapFile nextULong.
    ^bitmapInfo!   
readBitmapInfo: aStream
        "Private - Answer an instance of WinBitmapInfoHeader
         read from aStream . aStream position is updated."

    | bitmapInfo size rgb rgbTriple position byteArray coreHeader count |
    position := aStream position.
    size := aStream nextULong.
    aStream position: position.
    size = 12
        ifTrue: [   "OS/2 1.2 format."
            coreHeader := SelfDefinedStructure named: 'OS2BITMAPCOREHEADER'.
            coreHeader contents
                replaceFrom: 1
                to: coreHeader contents size
                with: aStream contents
                startingAt: position + 1.
            position := position + size.
            rgbTriple := ByteArray new: ((1 bitShift: coreHeader bitCount) * 3).
            rgbTriple
                replaceFrom: 1
                to: rgbTriple size
                with: aStream contents
                startingAt: position + 1.
            position := position + rgbTriple size.
            bitmapInfo := WinBitmapInfoHeader
                width: coreHeader width
                height: coreHeader height
                planes: 1
                bitCount: (coreHeader bitCount * coreHeader planes).
            coreHeader bitCount = 24 ifFalse: [
                rgb := ByteArray new: ((1 bitShift: coreHeader bitCount) * 4).
                count := 0.
                1 to: rgbTriple size by: 3 do: [: i |
                    rgb at: i + count put: (rgbTriple at: i).
                    rgb at: i + 1 + count  put: (rgbTriple at: i + 1).
                    rgb at: i + 2 + count put: (rgbTriple at: i + 2).
                    rgb at: i + 3 + count put: 0.
                    count := count + 1 ]]]

        ifFalse: [  "Windows or OS/2 2.0 format."
            byteArray  := ByteArray new: size.
            byteArray replaceFrom: 1
                to: size
                with: aStream contents
                startingAt: position + 1.
            position := position + size.
            bitmapInfo := WinBitmapInfoHeader fromBytes: (
                byteArray copyFrom: 1 to: WinBitmapInfoHeader sizeInBytes).
            bitmapInfo biSize: WinBitmapInfoHeader sizeInBytes.

            bitmapInfo bitCount = 24
                ifFalse: [
                    rgb := ByteArray new: (WinBitmapInfo colorTableSize: bitmapInfo bitCount).
                    rgb replaceFrom: 1
                        to: rgb size
                        with: aStream contents
                        startingAt: position + 1.
                        position := position + rgb size ] ].
    bitmapInfo := WinBitmapInfo fromBytes: (
        rgb isNil
            ifTrue: [ bitmapInfo contents ]
            ifFalse: [ bitmapInfo contents, rgb ] ).
    aStream position: position.
    ^bitmapInfo!   
width: w height: h bits: aByteArray
        "Answer a new Bitmap with width w and height h
        and bits copied from aByteArray."
    ^self new width: w height: h bits: aByteArray!  !

!Bitmap methods !
archive
        "Private - answer the archive bits."
    ^archive!  
archive: aByteArray
        "Private - set the receiver's archive bits to aByteArray."
    archive := aByteArray.!  
asParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to a host procedure call."
    ^self handle!   
bitmapHandle
        "Answer the handle of the receiver without
        bringing it to life."
    ^bitmapHandle!   
changeSize: extent
        "Change the size of the receiver to extent."
    | clone |
    clone := self clone.
    self release.
    self width: extent x
        height: extent y
        planes: self planes
        bitCount: self bitCount.
    self pen
        copyBitmap: clone
        from: clone boundingBox
        to: self boundingBox.
    clone release!  
clone
        "Answer a new bitmap which has the same
        attributes as the receiver."
    | clone bits dc |
    archive isArray ifTrue: [   "can't clone a bitmap from a dll."
        ^self ].
    clone := self class new.
    bits := ( archive isNil          "must be done before copying bitmapInfo to"
        ifTrue: [ self getDIBits ]  "ensure the color table is created."
        ifFalse: [ archive ] ).
    clone bitmapInfo: bitmapInfo deepCopy.
    dc := ( ( deviceContext isNil or: [ deviceContext = MemoryContext ] ) or: [
        deviceContext = OldMemoryContext ] )
            ifTrue: [ self class memoryContext ]
            ifFalse: [ self class createCompatibleDC: Display deviceContext ].
    clone
        deviceContext: dc ;
        graphicsTool: ( Pen for: dc medium: clone ).
    clone createBitmap: bits.
    ^clone!   
createBitmap
        "Private - Create a Windows bitmap for the receiver.
         Answer the handle of the bitmap."
    | handle |
    handle := bitmapInfo bitCount = 1
        ifTrue: [
            self class
                createBitmap: self width
                height: self height
                planes: 1
                bitCount: 1
                bits: nil ]
        ifFalse: [
            self class
                createDIBitmap: Display deviceContext
                bitmapInfo: bitmapInfo
                init: nil
                bits: nil
                usage: DibRgbColors ].
    bitmapHandle := handle.
    BitmapHandleTable at: handle put: self!   
createBitmap: bits
        "Private - Create a Windows bitmap for the receiver and
         initialize the bitmap with bits. Answer the handle of the
         bitmap."
    | handle hdc hPrevious |
    (hdc := UserLibrary getDC: nil) = 0
        ifTrue: [ ^self osError ].
    palette := self createDIBPalette.
    palette == nil
        ifFalse: [
            hPrevious := UserLibrary
                selectPalette: hdc
                with: palette asParameter
                forceBackground: false.
            UserLibrary realizePalette: hdc ].
    bitmapInfo bitCount = 1
        ifTrue: [
            handle := self class
                createBitmap: self width
                height: self height
                planes: 1
                bitCount: 1
                bits: nil.
            GDILibrary
                setDIBits: hdc
                hBitmap: handle
                startScan: 0
                scans: self height
                bitsStruct: bits asParameter
                bitsInfo: bitmapInfo asParameter
                wUsage: DibRgbColors]
        ifFalse: [
            handle := self class
                createDIBitmap: hdc
                bitmapInfo: bitmapInfo
                init: CbmInit
                bits: bits
                usage: DibRgbColors ].
    palette == nil ifFalse: [
        UserLibrary
            selectPalette: hdc
            with: hPrevious
            forceBackground: false].
    UserLibrary releaseDC: nil with: hdc.
    bitmapHandle := handle.
    BitmapHandleTable at: handle put: self!   
createDIBPalette
        "Private - Create a GDI palette from the color table of
          bitmapInfo."
    | logPalette |
    self bitCount > 8 ifTrue: [ ^nil ].
    "self bitCount = 24 ifTrue: [^0]."

    logPalette := WinLogicalPalette fromWinLogPalette: (
        WinLogPalette fromRgbColor: bitmapInfo colorTable).
    ^logPalette
    "^GDILibrary createPalette: logPalette asParameter"!
deselect
        "Deselect the receiver from the device context."
    UserLibrary selectPalette: deviceContext
        with: DefaultPaletteHandle
        forceBackground: false.
    ^GDILibrary selectObject: deviceContext
        with: DefaultBitmap!  
deselectFromAuxDC: hPrevious
        "Private - Deselect the receiver from the auxillary
         device context."
    UserLibrary selectPalette: AuxillaryDC
        with: DefaultPaletteHandle
        forceBackground: false.
    ^GDILibrary selectObject: AuxillaryDC
        with: hPrevious!
displayAt: aPoint with: aPen
        "Display the receiver at aPoint on aPen's medium
         using aPen."
    aPen notNil ifTrue: [
        aPen copyBitmap: self
            from: self boundingBox
            at: aPoint ]!
displayIn: aRect with: aPen
        "Display the receiver in aRect using aPen."
    aPen copyBitmap: self
        from: self boundingBox
        to: aRect!   
extent: aPoint
        "Private - Initialize the receiver with extent aPoint."
    ^self width: aPoint x height: aPoint y!  
fileInActivate: anObjectFiler
        " Activate instance which has just been loaded. "
    deviceContext notNil ifTrue: [ ^self ].  " already activated "
    self deviceContext: OldMemoryContext.
    ^self!   
fileOutSurrogate: anObjectFiler
        " Answer surrogate for object filing.
          Save bitmap in archive; don't store DC, pen, or bitmapHandle. "
    | surrogate instVarNames |
    self saveBitmap.
    surrogate := self copy.
    instVarNames := surrogate class allInstVarNames.
    surrogate   " clear system resource handles to nil "
        instVarAt: (instVarNames indexOf: 'deviceContext') put: nil;
        instVarAt: (instVarNames indexOf: 'graphicsTool') put: nil;
        instVarAt: (instVarNames indexOf: 'bitmapHandle') put: nil;
        instVarAt: (instVarNames indexOf: 'palette') put: nil.
    ^surrogate! 
fromModule: aModuleName id: bitmapName
        "Private - Load the receiver from the module
        aModuleName with id bitmapName."
    | bitmapStruct hLibrary path |
    aModuleName notNil ifTrue: [
        (hLibrary := KernelLibrary loadLibrary: aModuleName asParameter) < 32 ifTrue: [
            ^self error: 'Can not open DLL, error code: ', hLibrary asString ]].
    (bitmapHandle := UserLibrary
        loadBitmap: hLibrary asParameter
        name: bitmapName asParameter) = 0
            ifTrue: [ ^self error: 'LoadBitmap ', bitmapName asString, ' failed from module ', aModuleName asString ].
    BitmapHandleTable at: bitmapHandle put: self.
    (hLibrary notNil and: [ aModuleName isString ]) ifTrue: [
        KernelLibrary freeLibrary: hLibrary ].

    "use archive to save dll name and id."
    archive := Array with: aModuleName with: bitmapName.
    GDILibrary
        getObject: bitmapHandle
        count: WinBitmapStruct sizeInBytes
        lpObject: ( bitmapStruct :=  WinBitmapStruct new ) asParameter.
    bitmapInfo := WinBitmapInfo
        width: bitmapStruct width
        height: bitmapStruct height
        planes: 1
        bitCount: bitmapStruct planes * bitmapStruct bitsPixel.
    deviceContext := self class memoryContext.
    graphicsTool := Pen forDC: deviceContext medium: self.
    graphicsTool
        width: bitmapInfo width;
        height: bitmapInfo height!   
fromSysID: id
    "Added by OSI"
    | handle bitmap |
    #addedByOSI.
    ^self fromModule: nil id: id! 
getCb: bitCount
        "Private - Answer the size of the bitmapInfo struct."
    | count |
    count := WinBitmapInfoHeader sizeInBytes.
    bitCount >= 24
        ifTrue: [^count]     "No color table for this format."
        ifFalse: [^(count + (4 * (1 bitShift: bitCount)))]! 
getDIBits
        "Answer a ByteArray which contains the bits
         of the receiver in device independent format."
    | bits bytes hPrevious hdc |
    self validate.      "make sure handle is valid."
    (hdc := UserLibrary getDC: nil) = 0
        ifTrue: [ ^self osError ].
    palette == nil ifFalse: [
        hPrevious := UserLibrary
            selectPalette: hdc
            with: palette asParameter
            forceBackground: false.
        UserLibrary realizePalette: hdc ].

    "call GetDIBits with nil to fill in the rest of bitmapInfo."
    GDILibrary
        getDIBits: hdc
        hBitmap: self handle
        startScan: 0
        scans: self height
        bits: nil
        bitsInfo: bitmapInfo asParameter
        wUsage: DibRgbColors.

    bytes := self sizeInBytes.
    bits := ByteArray new: bytes.
    GDILibrary getDIBits: hdc
        hBitmap: self handle
        startScan: 0
        scans: self height
        bitsStruct: bits asParameter
        bitsInfo: bitmapInfo asParameter
        wUsage: DibRgbColors.

    palette  == nil ifFalse: [
        UserLibrary
            selectPalette: hdc
            with: hPrevious
            forceBackground: false ].
    UserLibrary releaseDC: nil with: hdc.
    ^bits!
handle
        "Private - Answer the handle."
    self validate.
    ^bitmapHandle!
initHandle
        "Private - the receiver has been released, set the handle to nil."
    BitmapHandleTable removeKey: bitmapHandle ifAbsent: [ ].
    graphicsTool := nil.
    bitmapHandle := nil.
    palette := nil.
        "set variable to indicate type of device context to restore."
    deviceContext :=
        ( deviceContext isNil or: [ deviceContext  = MemoryContext ] )
            ifTrue: [ nil ]
            ifFalse: [ DeviceContext new ]!  
initPenWidth: width height: height planes: planes bitCount: bitCount forDC: aDeviceContext
        "Private - Initialize the receiver's pen."

    | bitsPel |
    bitsPel :=  ( bitCount > 8 "and: [  OperatingSystem isWin32s ]" )
        ifTrue: [ 24 ]    "16 and 32 bit count not supported in Win16"
        ifFalse: [ bitCount ].
    bitmapInfo := WinBitmapInfo
        width: width
        height: height
        planes: 1
        bitCount: bitsPel.

    deviceContext := aDeviceContext.
    graphicsTool := Pen forDC: aDeviceContext medium: self.
    graphicsTool
        width: width;
        height: height! 
isValid
        "Answer true if the bitmap has a handle or archive."
    ^bitmapHandle notNil or: [archive notNil]! 
outputToFile: aFileName
        "Output the receiver in DIB format to aFileName."
    | aFileStream |
    aFileStream := (File pathName: aFileName) asByteFileStream.
    self outputToFileStream: aFileStream.
    aFileStream close.!  
outputToFileStream: aFileStream
        "Output the receiver in DIB format to aFileStream."
    | fileHeader bits |
    bits := self getDIBits.
    bits isNil ifTrue: [ ^self ].
    fileHeader := WinBitmapFileHeader new.
    fileHeader bfType: 'BM';
        bfSize: 14 + bitmapInfo contents size + bits size;
        reserved1: 0;
        reserved2: 0;
        offBits: 14 + bitmapInfo contents size.
    aFileStream nextPutAll: fileHeader contents.
    aFileStream putBytesFrom: bitmapInfo contents.
    aFileStream putBytesFrom: bits.!
palette
    ^palette!
release
        "Delete the receiver from the device context. Freeing
          up all system storage associated with the receiver."
    bitmapHandle isNil ifTrue: [ ^self ].
    self deselect.
    deviceContext = MemoryContext
        ifFalse: [ graphicsTool deleteDC ].
    GDILibrary deleteObject: bitmapHandle.
    self initHandle.!  
restoreBitmap
        "Private - Recreate the receiver and copy the bits
         from the archive buffer. This is done upon restarting
         a saved image."
    | dc |
    archive isNil ifTrue: [
        bitmapHandle := nil.
        ^self ].
    archive isArray ifTrue: [   "bitmap is from a dll"
        ^self fromModule: ( archive at: 1 ) id: ( archive at: 2 ) ].
    self createBitmap: archive.
    dc := ( ( deviceContext isNil or: [ deviceContext = MemoryContext ] ) or: [
        deviceContext = OldMemoryContext ] )
            ifTrue: [ self class memoryContext ]
            ifFalse: [ self class createCompatibleDC: Display deviceContext ].

    self
        deviceContext: dc;
        graphicsTool: (Pen forDC: dc medium: self).
    bitmapHandle notNil ifTrue: [ archive := nil]! 
saveBitmap
        "Private - Save the receiver's bits in an archive buffer
          when saving image."
    bitmapHandle isNil ifTrue: [ ^self ].
    "archive := self getDIBits."
    archive isArray ifFalse: [  "not from a dll"
        archive := self getDIBits ].
    self release!   
select
        "Private - Select the receiver into the device context
         and answer the previously selected bitmap handle."
    self validate.
    (deviceContext = MemoryContext and: [ graphicsTool notNil ])
        ifTrue: [ graphicsTool resetAttributes ].
    palette == nil ifFalse: [
        UserLibrary selectPalette: deviceContext
            with: palette asParameter
            forceBackground: false.
        UserLibrary realizePalette: deviceContext].
    bitmapHandle notNil
        ifTrue: [ GDILibrary selectObject: deviceContext with: bitmapHandle ].!  
selectToAuxDC
        "Private - Select the receiver into the auxillary
         device context."
    self deselect.
    self validate.
    palette == nil ifFalse: [
        UserLibrary
            selectPalette: AuxillaryDC
            with: palette asParameter
            forceBackground: false.
        UserLibrary realizePalette: AuxillaryDC ].
    bitmapHandle notNil
        ifTrue: [ ^GDILibrary selectObject: AuxillaryDC with: self handle ]!
setDIBits: aByteArray
        "Private - Set the bitmap bits of the receiver to aByteArray."
    self setDIBits: aByteArray using: bitmapInfo!  
setDIBits: aByteArray using: aBitmapInfo
        "Private - Set the bitmap bits of the receiver to aByteArray."
    | hdc result |
    hdc := UserLibrary getDC: nil.
    result := GDILibrary
        setDIBits: hdc
        hBitmap: self handle
        startScan: 0
        scans: self height
        bitsStruct: aByteArray asParameter
        bitsInfo: aBitmapInfo asParameter
        wUsage: DibRgbColors.
    UserLibrary releaseDC: nil with: hdc.
    result = 0 ifTrue: [ self osError ]! 
validate
        "Private - Restore from archive if necessary."
    | state |
    state := Process enableInterrupts: false.

    ((bitmapHandle isNil
        or: [bitmapHandle = NullHandle])
        and: [archive notNil]) ifTrue: [
           bitmapHandle := WinHandle new.
           self restoreBitmap].

    Process enableInterrupts: state!
width: w height: h planes: planes bitCount: bitsPixel
        "Initialize the receiver with w and h
         as its width and height."
    | bitCount hOldBitmap |
    bitCount := planes * bitsPixel.
    self initPenWidth: w
        height: h
        planes: 1
        bitCount: bitCount.
    bitmapInfo bitCount: bitCount.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap!    !

!DIB class methods ! 
fromFile: bitmapFile
        "Create a DIB bitmap from bitmapFile"
    ^self fromFile: bitmapFile in: Disk! 
fromFile: aFileName in: aDirectory
    "Read a DIB bitmap from a file named aFileName."
    | stream answer |
    stream := File pathNameReadOnly: aFileName in: aDirectory.
    answer := self fromFileStream: stream.
    stream close.
    ^answer!  
fromFileStream: aFileStream
        "Create a DIB bitmap from bitmapFile"
    | file dib type |
    file := aFileStream asByteFileStreamCopy.
    type := String new: 2.
    type at: 1 put: file next.
    type at: 2 put: file next.
    "check file type and position file pointer to DIB's info header."
    type  = 'BM'
        ifTrue: [file skip: 12]
        ifFalse: [
            type = 'BA'
                ifTrue: [file skip: 26]
                ifFalse: [
                    file close.
                    self error: 'Invalid bitmap format'.
                    ^nil]
            ].

    dib := self new
        fromStream: file.
    ^dib! !

!DIB methods !   
asDIB
    ^self! 
bitCount
        "Answer the bitCount field of bitmapInfo structure."
    ^bitmapInfo bitCount! 
bitmapInfo
    ^bitmapInfo!  
bitmapInfo: aWinBitmapInfo
    bitmapInfo := aWinBitmapInfo! 
bits
    ^bits!  
bits: aByteArray
    bits := aByteArray! 
createDIBPalette
        "Private - Create a GDI palette from the color table of
          bitmapInfo."
    | logPalette |
    self bitCount = 24 ifTrue: [^0].
    logPalette := WinLogPalette fromRgbColor: bitmapInfo colorTable.
    ^GDILibrary createPalette: logPalette asParameter! 
displayWith: destPen from:sRectangle to: dRectangle rule: aRopConstant
        "Copy sRectangle from the receiver to dRectangle in the destPen medium
          using aRopConstant.
          Data will be compressed or streched if
          the two rectangle are not the same extent."
        "Fixed by SNI - Select the receiver palette  before
        to display it"

    |answer destinationDC hPrevious isMemDC hPalette hPPalette pBits|
    destinationDC := destPen handle.
    (isMemDC := ((destPen graphicsMedium isBitmap) and: [
        destPen graphicsMedium deviceContext = Bitmap memoryContext]))
        ifTrue: [
            destinationDC := Bitmap auxillaryDC.
            hPrevious := destPen graphicsMedium selectToAuxDC].

    (hPalette := self createDIBPalette) ~= 0
        ifTrue: [
            hPPalette := UserLibrary selectPalette: destinationDC
                with: hPalette
                forceBackground: false.
            UserLibrary realizePalette: destinationDC].
    pBits := WinAddress copyToNonSmalltalkMemory: bits asParameter.
    answer := GDILibrary
        stretchDIBits: destinationDC
        xDest: dRectangle left
        yDest: dRectangle top
        cxDest: dRectangle width
        cyDest: dRectangle height
        xSrc: sRectangle left
        ySrc: sRectangle top
        cxSrc: sRectangle width
        cySrc: sRectangle height
        bits: pBits asParameter
        bmi: bitmapInfo asParameter
        colorUse: DibRgbColors
        rop: aRopConstant.

    pBits unlockAndFree.

    hPalette ~= 0
        ifTrue: [
            UserLibrary selectPalette: destinationDC
                with: hPPalette
                forceBackground: false.
            GDILibrary deleteObject: hPalette].

    isMemDC ifTrue: [
        destPen graphicsMedium deselectFromAuxDC: hPrevious].
    ^answer! 
fromStream: aStream
        "Private - Set the receiver's instance variables,
        parsing aStream. aStream must point to the DIB's
        info header."
    | bytes |
    bitmapInfo := Bitmap readBitmapInfo: aStream.
    bitmapInfo sizeImage = 0
        ifTrue: [ bytes := (((
            bitmapInfo width * bitmapInfo bitCount) + 31) // 32 * 4) * bitmapInfo height ]
        ifFalse: [ bytes := bitmapInfo sizeImage ].

    bits := ByteArray new: bytes.
    bits replaceFrom: 1
        to: bytes
        with: aStream contents
        startingAt: aStream position + 1.! 
numberOfColors
        "Answer the number of colors in the bitmap."
    self bitCount = 24
        ifTrue: [^0]         "A 24 bitCount bitmap has no color table."
        ifFalse: [^(1 bitShift: self bitCount)]! !

!GraphicsTool methods !  
copy: srcPen from: aRectangle at: aPoint rule: aRopConstant
        "Copy aRectangle from the scrPen medium to the
         receiver medium at aPoint using aRopConstant.
         aRopConstant defines how the source is combined with
         the destination."
    | destinationDC isMemDC hPrevious |
    destinationDC := self handle.
    (isMemDC := (graphicsMedium isBitmap and: [
        graphicsMedium deviceContext = Bitmap memoryContext ]))
        ifTrue: [
            destinationDC := Bitmap auxillaryDC.
            hPrevious := graphicsMedium selectToAuxDC].
    srcPen graphicsMedium isBitmap
        ifTrue: [ srcPen graphicsMedium select ].
    Bitmap
        bitBlt: destinationDC
        x: aPoint x
        y: aPoint y
        width: aRectangle width
        height: aRectangle height
        srcDC: srcPen handle
        xSrc: aRectangle origin x
        ySrc: aRectangle origin y
        rop: aRopConstant.
    srcPen graphicsMedium isBitmap
        ifTrue: [ srcPen graphicsMedium deselect ].
    isMemDC ifTrue: [
        graphicsMedium deselectFromAuxDC: hPrevious].!
copy: srcPen from: sRectangle to: dRectangle rule: aRopConstant
        "Copy sRectangle from the scrPen medium to the
         receiver medium in dRectangle using aRopConstant.
         aRopConstant defines how the source is combined with
         the destination. Data will be stretched or compressed if
         the two rectangles are not the same extent."
    | destinationDC isMemDC hPrevious |
    destinationDC := self handle.
    (isMemDC := (graphicsMedium isBitmap and: [
        graphicsMedium deviceContext = Bitmap memoryContext]))
        ifTrue: [
            destinationDC := Bitmap auxillaryDC.
            hPrevious := graphicsMedium selectToAuxDC ].
    srcPen graphicsMedium isBitmap
        ifTrue: [ srcPen graphicsMedium select ].
    self
        stretchBlt: destinationDC
        x: dRectangle origin x
        y: dRectangle origin y
        dWidth: dRectangle width
        dHeight: dRectangle height
        srcDC: srcPen handle
        xSrc: sRectangle origin x
        ySrc: sRectangle origin y
        sWidth: sRectangle width
        sHeight: sRectangle height
        rop: aRopConstant.
    srcPen graphicsMedium isBitmap
        ifTrue: [ srcPen graphicsMedium deselect ].
    isMemDC
        ifTrue: [ graphicsMedium deselectFromAuxDC: hPrevious ].! 
handle
        "Answer the receiver's deviceContext handle."
    deviceContext isNil
        ifTrue: [
            graphicsMedium isWindow
                ifTrue: [ self setHandle: graphicsMedium getDC ]
                ifFalse: [
                    graphicsMedium isBitmap
                        ifTrue: [ self setHandle: Bitmap memoryContext ] ] ].
    ^deviceContext.!  !

!Icon class methods !
fromBitmap: aBitmap
        "Private - Answer a new instance of Icon copied from aBitmap."

    | andMask icon |
    andMask := Bitmap extent: self iconSize.
    andMask pen fill: andMask boundingBox rule: Blackness.
    icon := self fromBitmap: aBitmap andMask: andMask.
    andMask release.
    ^icon!   
fromFile: fileName
        "Answer an instance of Bitmap copied from fileName.
         fileName must have a '.ico' extension."

    | file icon |
    file := (File pathName: fileName) asByteFileStream.
    icon := self fromFileStream: file.
    file close.
    ^icon!  
fromFileStream: stream
        "Answer an instance of Icon from stream."
    | icon |
    icon := self  new.
    icon readOnly: false.
    icon fromFileStream: stream.
    ^icon!  
fromModule:aFileName id: anId
        "Answer an Icon object. aFileName is a DLL file name
        anId can be a string or an Integer"
    ^self new fromModule: aFileName id: anId!   
getAllInstances
        "Private - Answer all instances of Icon and its subclasses ( if any )."
    | icons iconClasses |
    iconClasses := self withAllSubclasses.
    icons := Array new.
    Smalltalk unusedMemory.     "force a garbage collect."
    iconClasses do: [ :each |
        icons := icons, each allInstancesPrim ].
    ^icons!
purgeUnusedIcons
        "Private - Purge unused icons from the system."
    |handles all allReadOnly icons iconObjects iconLibraries hLibrary refCount bag|
    all := IconHandleTable keys.
    allReadOnly := self getAllReadOnlyHandles.
    IconHandleTable := Dictionary new.
    IconHandleReadOnlyTable := Dictionary new.
    icons := self getAllInstances.
    iconObjects := icons select: [ :each | each readOnly not ].
    iconObjects := iconObjects select: [ :each | each privateHandle notNil ].
    handles := iconObjects collect: [ :each | each handle ].
    all do: [:each |
        (handles includes: each) ifFalse: [
            UserLibrary destroyIcon: each ]].
    iconObjects do: [ :each |
        IconHandleTable at: each handle put: each].

    iconLibraries := icons select: [:each | each readOnly ].
    iconLibraries := iconLibraries select: [ :each | each privateHandle notNil ].
    handles := iconLibraries collect: [ :each | each handle ].
    allReadOnly do: [:each |
        (handles includes: each)
            ifFalse: [
                refCount := IconLibraryTable at: each ifAbsent: [].
                refCount notNil ifTrue: [
                    KernelLibrary freeLibrary: refCount key asParameter.
                    refCount value: refCount value - 1.
                    refCount value = 0 ifTrue:[IconLibraryTable removeKey: refCount key ifAbsent: [] ]]]].
    iconLibraries do: [:each |
            (bag := IconHandleReadOnlyTable at: each handle ifAbsent: []) isNil
                ifTrue:[
                    IconHandleReadOnlyTable at: each handle put: (Bag with:each) ]
                ifFalse: [ bag add:each ]].! !

!Icon methods !  
asParameter
        "Answer the receiver in a form suitable for
         passing as a parameter to a procedure call."
    ^self handle!
createIcon
    "Modified by OSI - Included Digitalk's changes"
        "Private - Create a WINDOWS icon from the receiver."
    | temp bitsPixel planes bitCount |
    readOnly ifTrue:[ ^self ].
    bitsPixel := GDILibrary getDeviceCaps: Display pen handle
        index: Bitspixel.
    planes := GDILibrary getDeviceCaps: Display deviceContext
        index: Planes.
    bitCount := bitsPixel * planes.
    bitCount = xorMask bitCount
        ifTrue: [temp := xorMask]
        ifFalse: [                "create a bitmap compatible with the device."
            temp := Bitmap width: xorMask width height: xorMask height planes: 1 bitCount: bitCount.
            temp pen copyBitmap: xorMask
                from: xorMask boundingBox
                at: 0@ 0 ].

    hIcon := UserLibrary createIcon: WIN hInstance
        width: self extent x
        height: self extent y
        planes: temp planes
        bitsPixel: temp bitCount
        andBits: andMask getDDBits
        xorBits: temp getDDBits.
    hIcon = 0 ifTrue: [ ^self osError ].
    IconHandleTable at: hIcon put: self.
    bitCount = xorMask bitCount ifFalse: [ temp release ]!  
displayAt: aPoint with: aPen
        "Display the receiver through aPen at the given location."
    UserLibrary
        drawIcon: aPen handle
        x: aPoint x
        y: aPoint y
        hIcon: self handle.!  
findVGAImage: aStream
        "Private - Position the stream to the beginning of the
        VGA icon image, or report an error if not found."
    | idCount bWidth bHeight bColorCount found i |
    idCount := aStream nextUShort.
    i := 0.
    found := false.
    [ found or: [ i > idCount ] ] whileFalse: [
        i := i + 1.
        bWidth := aStream nextByte.
        bHeight := aStream nextByte.
        bColorCount := aStream nextByte.
        ( ( ( bWidth = 32 ) and: [ bHeight = 32 ] ) and: [ bColorCount = 16 ] )
            ifTrue:[ found := true ]
            ifFalse: [ aStream skip: 13 ] ].
    found ifFalse: [ ^self error: 'Unsupported icon format' ].
    aStream skip: 9.! 
fromFileStream: stream
        "Answer an instance of Bitmap from stream."
    | type dibOffset pos |
    pos := stream position.
    type := stream nextUShort.
    "First check for OS/2 icon format"
    (#(16r4349 16r4943 16r5450 16r5043) includes: type)
        ifTrue: [                     "OS/2 single version format."
            stream skip: 12.          "skip file header."
            ^self fromFileStreamOS2: stream]
        ifFalse: [
            type = 16r4142
                ifTrue: [               "multiple versions format"
                    stream skip: 12.    "skip bitmap array file header."
                    type := stream nextUShort.
                    (#(16r4349 16r4943 16r5450 16r5043) includes: type)
                        ifTrue: [stream skip: 12]
                        ifFalse: [^self error:'Resource is not an Icon'].
                    ^self fromFileStreamOS2: stream]].

    "Now check for Windows icon format."
    (type = 0 and: [stream nextUShort = 1])
        ifFalse: [^self error:'Resource is not an Icon'].
    self findVGAImage: stream.
    dibOffset := stream nextULong.
    stream position: pos.
    stream skip: dibOffset.

    self readBitmapsFromFileStream: stream!   
fromFileStreamOS2: fileStream
        "Private - Answer an instance of Icon read from aFileStream.
         The icon stored in fileStream is an OS/2 icon."
    | bitmap bitmapInfo clrBitmapInfo bits colorBits  |
    bitmapInfo := Bitmap readBitmapInfo: fileStream.
    fileStream skip: 14.    "Skip color bitmap file header."
    clrBitmapInfo := Bitmap readBitmapInfo: fileStream.
    bits := ByteArray new: (((bitmapInfo bitCount * bitmapInfo width) + 31) // 32) *
        4 * bitmapInfo height * bitmapInfo planes.
    fileStream getBytesFor: bits.

    bitmap := Bitmap new.
    bitmap bitmapInfo: bitmapInfo.
    bitmap deviceContext: Bitmap memoryContext;
        graphicsTool: (
            Pen forDC: Bitmap memoryContext medium: bitmap).
    bitmap createBitmap: bits.

    "Read color bitmap bits"
    colorBits := ByteArray new: (((clrBitmapInfo bitCount * clrBitmapInfo width) + 31) // 32) *
        4 * clrBitmapInfo height * clrBitmapInfo planes.
    fileStream getBytesFor: colorBits.

    "Create XOR mask from color bits."
    xorMask := Bitmap new.
    xorMask bitmapInfo: clrBitmapInfo.
    xorMask
        deviceContext: (Bitmap memoryContext);
        graphicsTool: (
            Pen forDC: Bitmap memoryContext medium: xorMask).
    xorMask createBitmap: colorBits.

    "Create AND mask from bitmap."
    andMask := Bitmap width: bitmap width height: bitmap height // 2.
    andMask pen                                             "only copy AND mask portion."
        copyBitmap: bitmap
        from: (0 @ 0 extent: (
                bitmap width @ (bitmap height // 2)))
        at: 0 @ 0.

    bitmap release!   
handle
        "Private - Answer the receiver's handle."
    self validate.
    ^hIcon!
hasHandle
        "Answer whether the handle is valid."
    ^(hIcon notNil and: [hIcon ~= 0])!  
initHandle
        "Private - the receiver has been released, set the handle to nil."
    readOnly ifTrue: [ ^self releaseReadOnly ].
    IconHandleTable removeKey: hIcon ifAbsent: [ nil ].
    hIcon := nil.
    self releaseBitmaps! 
isValid
        "Answer whether the receiver has a handle or bits."
    ^self hasHandle or: [self andMask notNil]!  
outputToFile: aFileName
        "Private - Output the receiver in DIB format to aFileName."
    | file aFileStream |
    file := File fromPath: aFileName.
    file exists ifTrue: [ file remove ].
    file create.
    aFileStream := file asByteFileStream.
    self outputToFileStream: aFileStream.
    aFileStream close.!  
outputToFileStream: aFileStream
        "Output the receiver in DIB format to aFileStream."
    | bihXorBits andBits |
    bihXorBits := xorMask getIconHeaderDIBits.
    andBits := andMask getDIBits.
    aFileStream
        nextTwoBytesPut: 0;
        nextTwoBytesPut: 1;
        nextTwoBytesPut: 1;
        nextBytePut: xorMask width;
        nextBytePut: xorMask height;
        nextBytePut: xorMask numberOfColors;
        nextBytePut: 0;
        nextTwoBytesPut: 0;
        nextTwoBytesPut: 0;
        nextFourBytesPut: bihXorBits size + andBits size ;
        nextFourBytesPut: 22;
        putBytesFrom: bihXorBits;
        putBytesFrom: andBits.!
readBitmapsFromFileStream: aFileStream
    "Private - read the xorMask and andMask bitmaps for the receiver
      from aFileStream."

    | andBitInfo xorBitInfo andMaskSize xorBits andBits |
    xorBitInfo := Bitmap readBitmapInfo: aFileStream.
    xorBitInfo height: xorBitInfo height // 2.
    andMaskSize := xorBitInfo width / 8 * xorBitInfo width.
    xorBitInfo sizeImage: xorBitInfo sizeImage - andMaskSize.

    xorBits := ByteArray new: xorBitInfo sizeImage.
    andBits := ByteArray new: andMaskSize.
    aFileStream getBytesFor: xorBits.
    aFileStream getBytesFor: andBits.

    "Create AND and XOR bitmap objects but don't create
      OS objects until needed. "
    andMask := Bitmap new.
    andBitInfo := WinBitmapInfo
        width: xorBitInfo width
        height: xorBitInfo height
        planes: 1
        bitCount: 1
        size: ( WinBitmapInfo getCb: 1 ).
    andBitInfo colorTable: (
        (ByteArray with: 0 with: 0 with: 0 with: 0) , (
        ByteArray with: 255 with: 255 with: 255 with: 0)).
    andMask
        bitmapInfo: andBitInfo;
        archive: andBits;
        deviceContext: Bitmap memoryContext;
        graphicsTool: ( Pen for: Bitmap memoryContext medium: andMask ).

    xorMask := Bitmap new
        bitmapInfo: xorBitInfo;
        archive: xorBits;
        deviceContext: Bitmap memoryContext;
        graphicsTool: ( Pen for: Bitmap memoryContext medium: xorMask )! 
release
        "Release the receiver's resources from memory."
    readOnly ifTrue:[^self releaseReadOnly].
    hIcon isNil ifTrue:[^self].
    UserLibrary destroyIcon: self handle.
    self initHandle!  
releaseBitmaps
        "Private - Release the bitmaps of the receiver from the system."
    andMask notNil ifTrue: [andMask saveBitmap].
    xorMask notNil ifTrue: [xorMask saveBitmap]!  
validate
        "Private - Validate the receiver by recreating
          it from  the original parameters if necessary."
    | refCount bag |
    hIcon notNil ifTrue:[^hIcon].
    readOnly
        ifTrue:[
            hIcon :=self handleReadOnly.
            (bag := IconHandleReadOnlyTable at: hIcon ifAbsent:[]) isNil
                ifTrue:[
                    IconHandleReadOnlyTable at: hIcon
                        put: (Bag with:self) ]
                ifFalse:[ bag add:self ].
            (refCount := IconLibraryTable at: hIcon ifAbsent:[]) notNil
                ifTrue:[ refCount value: refCount value + 1 ]
                ifFalse:[
                    IconLibraryTable at: hIcon
                        put: (Association key: hLibrary value: 1)].
            ^hIcon]
        ifFalse:[ self createIcon ].
    ^hIcon!    !

!TopPane methods !   
wmPalettechanged: wParam with: lParam
    "BEWARE - do not remove the palette message handlers  without first
    removing the matching entry in WinEvents"
    "Process WM_PALETTECHANGED message"
     | hdc palette |
    palette := self propertyAt: #palette ifAbsent: [ ^nil ].
    wParam = ((self handle) asInteger)
        ifFalse:[ hdc := self getDC.
                      UserLibrary selectPalette: hdc
                                                         with: palette handle forceBackground: false.
                      ( UserLibrary realizePalette: hdc ) > 0
                            ifTrue:  [ GDILibrary updateColors: hdc ].
                      self releaseDC:  hdc
                    ].
    ^nil!   
wmQuerynewpalette:  wParam with: lParam
    "BEWARE - do not remove the palette message handlers  without first
    removing the matching entry in WinEvents"
    "Process WM_QUERYNEWPALETTE message"
       | hdc  palette |

    palette := self propertyAt: #palette ifAbsent: [ ^0 ].
    hdc := self getDC.
    UserLibrary selectPalette:  hdc with:   palette handle  forceBackground: false.
    ( UserLibrary realizePalette: hdc) > 0
            ifTrue: [  self invalidateRect: self boundingBox].
    self releaseDC:  hdc.
    ^nil! !

!WinBitmapFileHeader class methods ! 
inspectorFields
        "Answer the names of the fields contained in this kind of definition."
    ^self inspectorClass fields: #(
        bfType
        bfSize
        reserved1
        reserved2
        offBits
    )! !

!WinBitmapFileHeader methods !   
bfSize
    ^self uLongAtOffset: 2!   
offBits
    ^self uLongAtOffset: 10! 
reserved1
    ^self uShortAtOffset: 6!   
reserved2
    ^self uShortAtOffset: 8! !

!WinBitmapInfo class methods !   
colorTableSize: bitCount
        "Private - Answer the size of the color table."
    bitCount <= 8
        ifTrue: [  ^( 1 bitShift: bitCount ) * 4  ].
    ( bitCount = 16 or: [ bitCount = 32 ] )
        ifTrue: [ ^12 ].    "3 DWORD masks"
    ^0     "No color table for 24 bitCount format."!
getCb: bitCount
        "Private - Answer the size of the bitmapInfo struct ."
    | count |
    count := WinBitmapInfoHeader sizeInBytes.
    bitCount <= 8
        ifTrue: [  ^( count + ( 4 * ( 1 bitShift: bitCount )  ) ) ].
    ( bitCount = 16 or: [ bitCount = 32 ] )
        ifTrue: [ ^count + 12 ].    "3 DWORD masks"
    ^count     "No color table for 24 bitCount format."!
inspectorFields
        "Answer the names of the fields contained in this kind of definition."
    ^super inspectorFields, #( colorTable )! 
width: w height: h	planes: planes bitCount: bitCount
        "Answer a new instance of the receiver with width of w,
        height of h, planes of planes, bit count of bitCount and
        size of bytes."

    | bytes bitmapInfo |
    bytes := self getCb: bitCount.
    bitmapInfo := self new: bytes.
    bitmapInfo
        biSize: 40;
        width: w;
        height: h;
        planes: planes;
        bitCount: bitCount.
    ( bitCount = 16 or: [ bitCount = 32 ] ) ifTrue: [
        bitmapInfo
            compression: 3; "BI_BITFIELDS"
            clrUsed: 3;
            uLongAtOffset: 40 put: 16r7C00;
            uLongAtOffset: 44 put: 16r3E0;
            uLongAtOffset: 48 put: 16r1F ].
    ^bitmapInfo!  !

!WinBitmapInfoHeader class methods ! 
inspectorFields
        "Answer the names of the fields contained in this kind of definition."

    ^self inspectorClass fields: #(
        biSize
        width
        height
        planes
        bitCount
        compression
        sizeImage
        xPelsPerMeter
        yPelsPerMeter
        clrUsed
        clrImportant
    )!  
width: w height: h  planes: planes bitCount: bitCount
        "Answer a new instance of the receiver with width of w,
        height of h, planes of planes and bit count of bitCount."

    | bitmapInfoHeader |
    bitmapInfoHeader := self new.
    bitmapInfoHeader
        biSize: 40;
        width: w;
        height: h;
        planes: planes;
        bitCount: bitCount.
    ( bitCount = 16 or: [ bitCount = 32 ] ) ifTrue: [
        bitmapInfoHeader
            compression: 3; "BI_BITFIELDS"
            clrUsed: 3 ].
    ^bitmapInfoHeader!    !

!WinBitmapInfoHeader methods !   
biSize
    ^self uLongAtOffset: 0!   
biSize: bmInfoSize
        "Private - Set the number of bytes in the receiver."
    self uLongAtOffset: 0 put: bmInfoSize!  
clrUsed
    ^self uLongAtOffset: 32! 
compression
    ^self uLongAtOffset: 16! 
yPelsPerMeter
    ^self uLongAtOffset: 28! !

!WinBitmapStruct class methods ! 
inspectorFields
        "Answer the names of the fields contained in this kind of definition."
    ^self inspectorClass fields: #(
        bmType
        width
        height
        byteWidth
        planes
        bitsPixel
    )!   !

!WinBitmapStruct methods !   
bmType
    ^self shortAtOffset: 0! !

!Window class methods !  
disablePaletteMessages
    " Window disablePaletteMessages "
    WinEvents at:783 put:  nil.
    WinEvents at:785 put:  nil!   
enablePaletteMessages
    " Window enablePaletteMessages "
    ( GDIDLL canUnderstand: #updateColors: ) ifFalse: [ ^self error: 'Better not do this' ].
    ( self canUnderstand: #wmQuerynewpalette:with: )
        ifTrue: [ WinEvents at:783 put:  #wmQuerynewpalette:with: ].
    ( self canUnderstand: #wmPalettechanged:with: )
        ifTrue: [ WinEvents at:785 put:  #wmPalettechanged:with: ]! !

!Window methods !
wmPalettechanged: wParam with: lParam
    "BEWARE - do not remove the palette message handlers  without first
    removing the matching entry in WinEvents"
    ^nil!  
wmQuerynewpalette:  wParam with: lParam
    "BEWARE - do not remove the palette message handlers  without first
    removing the matching entry in WinEvents"
    ^nil!  !

!MDIChild methods !  
closeView 
        "Private - Close the receiver and all its children." 
 
    |answer active max| 
 
    self isHandleOk ifFalse: [^self]. "already closed" 
 
    answer:=super closeView. 
    answer isNil ifTrue:[ 
        ^nil]. 
 
    owner removeView: self. 
    self frame childClose. 
    self frame renumber:self. 
    active:=self frame mdiGetActive. 
    active isNil ifTrue:[self setInitMenu]. 
    self updateClient.
    ^answer!
initSize
        "Private - Answer the initial size of the receiver."
    | size |
    self frame isNil ifTrue: [^nil ].
    size := (owner respondsTo: #initMdiWindowSize)
        ifTrue: [ owner initMdiWindowSize ]
        ifFalse: [ self initMdiWindowSize ].
    ^size isRectangle
        ifTrue: [ size ]
        ifFalse: [
            size isPoint
                ifTrue: [ self boxOfSize: size ]
                ifFalse: [ 0 @ 0 extent: 100@100 ]].!
showMaximizedWindow
        "Private - Show the receiver window with maximized size."

    self frame mdiMaximize:self.
    "self resize: (self rectangle)"!  
superWindow
        "Answer the non-frame parent window of the receiver."
    ^self frame!    !

!MDIFrame methods !  
buildWindow
        "Private - Create the host window for the receiver."

    menuWindow:=self mdiInitMenu.
    ^super buildWindow.!  
wmCommand: wordInteger with: longInteger
        "Private - Process the command message.
        need to be reimplemented to send directly
        #performMenuItem to the menuWindow's owner."

    | control |
    (self helpModeCommand: wordInteger) notNil ifTrue:[ ^0 ].
    (( longInteger \\ 65536 ) > 0 or: [ self isDialogTopPane ])
        ifTrue: [                    "= 0 for 'enter' key"
            control :=  self childAtId: wordInteger.
            control notNil
                ifTrue: [ control
                    syncControlEvent: ( longInteger // 65536 ) ]]
        ifFalse: [
            "Modified by DMZ, OSI 2/1/97 to send #performMenuItem directly to
            the menuWindow. By sending it to the owner (ie. the MDIFrame) it is
            possible that the owner's menuWindow may change between now
            and when the message is performed."
            #modifiedByOSI.
            self menuWindow "owner" sendInputEvent: #performMenuItem:     "specify the receiver now !!"
                with: wordInteger ].

    ^nil!  
wmSize: wordInteger with: longInteger
        "Private - Process the erase wmSize message."
        "Reimplemented here because the MDIClient is
        resized by Smalltalk."

    rectangle := 0 @ 0 extent: 0 @ 0.
    super  wmSize: wordInteger with: longInteger.
    ^true!  !

!MDISystem class methods !   
mdiMenu
    "Private - Answer the standard MDI Window menu."
    ^MDIMenu new
    appendItem: '&New Window' selector:#mdiNewWindow;
    appendItem: '&Cascade    Shift+F5' selector: #mdiCascade accelKey: VkF5 accelBits: AfVirtualkey|AfShift ;
    appendItem: '&Tile    Shift+F4' selector: #mdiTile accelKey: VkF4 accelBits: AfVirtualkey|AfShift ;
    appendItem: 'Arrange &Icons' selector: #mdiArrange;
    appendItem: 'Close &All' selector: #mdiCloseAll;
    title: '&Window'.!   !

!StatusPane methods !
affectsFreeClientArea
        "Private - Answer whether the receiver reduces the amount of
        free client area in its parent for the receiver's siblings."

    ^true!   
isMDISupportPane
        "Answer true if receiver is a support pane for MDI."

    ^true!    !

!ToolPane methods !  
affectsFreeClientArea
    "Private - Answer whether the receiver reduces the amount of
    free client area in its parent for the receiver's siblings."
    ^true! 
isMDISupportPane
        "Answer true if receiver is a support pane for MDI."
    ^true!  !

!CompositePane methods ! 
contents
    "Answer the value of the receiver.
    This should be overriden in subclasses"
    ^nil!  
contents: anObject
    "Set the value of the receiver.
    This should be overriden in subclasses"! 
isMDISupportPane
        "Answer true if receiver is a support pane for MDI."
    | cpStyle |
    ^(cpStyle := self cpStyle) == #mdiToolBar or: [
        cpStyle == #mdiToolBarBordered]!  !

!File class methods !
findOrPromptFileName: fileName
    "Answer the full path of the file named fileName.
    Search the current search path, and if not found
    then prompt the user."

    | answer dialog |
    (answer := self findFileName: fileName) notNil ifTrue: [ ^answer ].
    dialog := FileDialog new
        title: 'Where is "', fileName, '" ?';
        fileSpec: fileName;
        hideReadonly.
    dialog open.
    (answer := dialog file) notNil ifTrue: [
        (self exists: answer) ifFalse: [
            MessageBox message: '"', answer fileNameLessPath, '" does not exist'.
            answer := nil ] ].
    ^answer!   !

!GraphicsTool methods !  
setBackgroundModeOpaque
    "Set the background mode."
    self setBackgroundMode:  2. "(GraphicsConstants at: 'BackgroundMixOpaque')"! 
setBackgroundModeTransparent
        "Set the background mode."
    self setBackgroundMode: 1. "(GraphicsConstants at: 'BackgroundMixTransparent')"!  !

!Number methods !
distanceDown: aNumber
        "Answer the distance between the receiver and aNumber
            where right and down are positive."

    ^(aNumber - self) * Rectangle topBottomUnit! 
distanceLeft: aNumber
        "Answer the distance between the receiver and aNumber
            where right and down are positive."

    ^aNumber distanceRight: self!
distanceRight: aNumber
        "Answer the distance between the receiver and aNumber
            where right and down are positive."

    ^(aNumber - self) * Rectangle leftRightUnit!
distanceUp: aNumber
        "Answer the distance between the receiver and aNumber
            where right and down are positive."

    ^aNumber distanceDown: self! !

!Object methods !
maxWindowSize
    "Added by OSI"
    #addedByOSI.
    ^nil!  !

!Point methods ! 
distanceLeftAndDown: aPoint
        "Answer the distance between the receiver and aPoint
            where left and down are positive."

    ^(x distanceLeft: aPoint x) @ (y distanceDown: aPoint y)!
distanceLeftAndUp: aPoint
        "Answer the distance between the receiver and aPoint
            where left and up are positive."

    ^(x distanceLeft: aPoint x) @ (y distanceUp: aPoint y)!  
distanceRightAndDown: aPoint
        "Answer the distance between the receiver and aPoint
            where right and down are positive."

    ^(x distanceRight: aPoint x) @ (y distanceDown: aPoint y)! 
distanceRightAndUp: aPoint
        "Answer the distance between the receiver and aPoint
            where right and up are positive."

    ^(x distanceRight: aPoint x) @ (y distanceUp: aPoint y)! !

!Rectangle class methods !   
leftRightUnit
        "Answer the signed unit from left to right."
    ^1!  
topBottomUnit
        "Answer the signed unit from top to bottom."
    ^1!    !

!Stream methods !
skipToWhitespace
        "Advance the receiver position beyond the next
         occurrence of whitespace, or if none, to the end of
         stream.  Answer true if whitespace occurred, else
         answer false."

    [self atEnd]
        whileFalse: [
            self next isWhitespace
                ifTrue: [^true]].
    ^false!
skipWhitespace
        "Advance the receiver position beyond the next
         occurrence of whitespace, or if none, to the end of
         stream.  Answer true if whitespace occurred, else
         answer false."

    [self atEnd]
        whileFalse: [
            self peek isWhitespace ifFalse: [^true].
            self next].
    ^false!  
upToWhitespace
        "Answer the contents from the current position
        to the next white space."

    ^self
        copyFrom: self position + 1
        to: (self skipToWhitespace
            ifTrue: [self position - 1]
            ifFalse: [self position])!    !

!String methods !
mnemonicChar

    "Added by OSI.  Scan for the mnenomic character (&), and
     answer the character following it.  If no mnemonic, answer nil."

    | index |
    #addedByOSI.
    index := (self indexOf: $& ifAbsent: [ self size ]) + 1.
    index > self size ifTrue: [
        ^nil
    ].

    ^(self at: index) asUpperCase!   !

!Window methods !
hasTransparentStyle
        "Answer whether the receiver has the transparent style."

    ^(self propertyAt: #transparent) = true!   !

!AboutDialog methods !   
open
        "Open a dialog box telling about Smalltalk/V."
    | lineHeight |
    self
        label: 'About'.

    lineHeight := 8.
    self addSubpane:
        (StaticText new
            centered;
            contents: 'Smalltalk Express v', Smalltalk version;
            framingBlock: [:box |
                (box leftTop down: lineHeight)
                    extentFromLeftTop: box width @ lineHeight ] ).

    self addSubpane:
        (StaticText new centered;
            contents: '(c) Copyright ParcPlace-Digitalk Inc. 1992-1996';
            framingBlock: [:box |  (box leftTop down: lineHeight * 3)
                    extentFromLeftTop: box width @ lineHeight ] ).

    self addSubpane:
        (StaticText new centered;
            contents: 'All rights reserved';
            framingBlock: [:box | (box leftTop down: lineHeight * 4)
                    extentFromLeftTop: box width @ lineHeight ] ).

    self addSubpane:
        (StaticText new centered;
            contents: '999 East Arques Ave.';
            framingBlock: [:box | (box leftTop down: lineHeight * 6)
                    extentFromLeftTop: box width @ lineHeight ] ).

    self addSubpane:
        (StaticText new centered;
            contents: 'Sunnyvale, CA 94086-4593';
            framingBlock: [:box | (box leftTop down: lineHeight * 7)
                    extentFromLeftTop: box width @ lineHeight ] ).

    self addSubpane:
        (StaticText new centered;
            contents: 'www.parcplace.com';
            framingBlock: [:box | (box leftTop down: lineHeight * 8)
                    extentFromLeftTop: box width @ lineHeight ] ).

    self addSubpane:
        (StaticText new centered;
            contents: 'Smalltalk Express is a trademark';
            framingBlock: [:box | (box leftTop down: lineHeight * 12)
                    extentFromLeftTop: box width @ lineHeight ] ).

    self addSubpane:
        (StaticText new centered;
            contents: 'of ParcPlace-Digitalk Inc.';
            framingBlock: [:box | (box leftTop down: lineHeight * 13)
                    extentFromLeftTop: box width @ lineHeight ] ).

    self addSubpane:
        (Button new defaultPushButton;
            idOK;
            contents: 'OK';
            when: #clicked perform: #ok:;
            framingBlock: [:box | (box leftTop rightAndDown:
                        (box width - 35) // 2 @ (lineHeight * 19 // 2))
                    extentFromLeftTop: 35 @ (lineHeight * 2)] ).

    self openWindow!   !

!ApplicationWindow methods ! 
buildWindow
        "Private - Create the host window for the receiver."
    |m|
    style isNil ifTrue: [ style := self getStyle ].
    NewWindow notNil ifTrue:[NewWindow := nil.  Terminal bell.^self].   "A Walkback came up during creation of window"
    NewWindow := self.
    self create: self winClass
        title: label
        style: style
        rectangle: (0@0 extent: 0@0)
        parent: parent.
    NewWindow := nil.

    handle = NullHandle ifTrue: [^nil].

    "menu and subpanes created in the wmCreate message process"

    "Set the size of the frame window."
    self handle setWindowPos: nil
            rectangle: rectangle
            fs: SwpNozorder.
    rectangle := self rectangle.

    m := UserLibrary
            getSystemMenu: self asParameter
            revert: 0.
    self propertyAt: #sysMenu put: m.

    self activeTextPane: self searchForDefaultTextPane.!   
getStyle
        "Answer the initial style of the receiver, composed of
       its basicStyle and its defaultStyle."
    ^self defaultFrameStyle!    !

!Bitmap class methods !  
createDIBitmap: hDC
    bitmapInfo: bitmapInfo
    init: initFlag
    bits: bits
    usage: usageFlag
        "Private - call the CreateDIBitmap API."
    | hBitmap bitmapInfoHeader bitsAddr |
    bitmapInfoHeader := WinBitmapInfoHeader
        width: bitmapInfo width
        height: bitmapInfo height
        planes: bitmapInfo planes
        bitCount: bitmapInfo bitCount.
    "Modified by DMZ, OSI 3/10/97 to copy bits into external memory before
    calling CreateDIBitmap api. This works around Win16 size limitation in
    directly passed structs."
    #modifiedByOSI.
    bitsAddr := WinAddress copyToNonSmalltalkMemory: bits.
    hBitmap := GDILibrary
        createDIBitmap: hDC
        infoHeader: bitmapInfoHeader asParameter
        dwUsage: initFlag
        initBits: bitsAddr asParameter
        initInfo: bitmapInfo asParameter
        wUsage: usageFlag.
    bitsAddr unlockAndFree.
    hBitmap = 0
            ifTrue: [ ^self osError ].
    ^hBitmap!  !

!Bitmap methods !
getDIBits
        "Answer a ByteArray which contains the bits
         of the receiver in device independent format."
    | bits bytes hPrevious hdc extraBytes tmpBitmapInfo bitsAddr |
    self validate.      "make sure handle is valid."
    (hdc := UserLibrary getDC: nil) = 0
        ifTrue: [ ^self osError ].
    palette == nil ifFalse: [
        hPrevious := UserLibrary
            selectPalette: hdc
            with: palette asParameter
            forceBackground: false.
        UserLibrary realizePalette: hdc ].

    "Following fix courtesy Ed Shirk - If an 8 bit bitmap has a color table with
    fewer than 256 entries and getDIBits is called, Windows writes the full
    256 entries.  This exceeds the size of the ByteArray pointed to by bitmapInfo.
    Object memory is overwritten and VWIN crashes instantly. The fix is to ensure
    that there is sufficient space."
    tmpBitmapInfo := bitmapInfo.
    bitmapInfo bitCount = 8 ifTrue:
        [ extraBytes := 1024 - bitmapInfo colorTable size .
        extraBytes > 0
            ifTrue: [ tmpBitmapInfo := WinBitmapInfo fromBytes: ( bitmapInfo contents, (ByteArray new: extraBytes) ) ] ].

    "call GetDIBits with nil to fill in the rest of bitmapInfo."
    GDILibrary
        getDIBits: hdc
        hBitmap: self handle
        startScan: 0
        scans: self height
        bits: nil
        bitsInfo: tmpBitmapInfo asParameter
        wUsage: DibRgbColors.

    "Modified by DMZ, OSI 3/10/97 to have getDIBits api copy bits into
    external memory. This works around Win16 size limitation in directly
    passed structs."
    bytes := self sizeInBytes.
    bitsAddr := WinAddress allocateMemory: bytes.
    GDILibrary getDIBits: hdc
        hBitmap: self handle
        startScan: 0
        scans: self height
        bits: bitsAddr asParameter
        bitsInfo: tmpBitmapInfo asParameter
        wUsage: DibRgbColors.
    bits := ByteArray new: bytes.
    WinAddress copyFrom: bitsAddr to: bits count: bytes.
    bitsAddr unlockAndFree.

    palette  == nil ifFalse: [
        UserLibrary
            selectPalette: hdc
            with: hPrevious
            forceBackground: false ].
    UserLibrary releaseDC: nil with: hdc.
    self bitmapInfo: tmpBitmapInfo.
    ^bits!    !

!DialogTopPane methods ! 
buildDialogItems
        "Private - Build the control items."
    children do: [ :subpane |
        subpane isSubPane ifTrue: [
            subpane buildDialogItem: handle ]].!  
isDialogTopPane
        "Answer whether the receiver is a kind of DialogTopPane."
    ^true!  !

!GraphPane class methods !   
openWindow: aTitleString extent: aPoint
        "Create a new window titled aTitleString and initial
          extent aPoint with a single GraphPane. Answer the
          GraphPane."
    | g w |
    w := ViewManager new.
    "Setting the style with WsClipchildren so that contents won't be
      erased prematurely during the use of Turtle Graphics."
    w    label: aTitleString;
          style:  w mainView getStyle | WsClipchildren;
          addSubpane: (g := self new
                   framingRatio: (0 @ 0 extent: 1 @ 1)).
     w mainView openIn: (w mainView boxOfSize: aPoint).
    ^g! !

!GroupPane methods ! 
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
    ^WsBorder | WsClipsiblings! !

!Object methods !
isDialogTopPane
        "Answer whether the receiver is a kind of DialogTopPane."
    ^false!   
isSubPane
        "Answer whether the receiver is a kind of SubPane."
    ^false! !

!SubPane methods !   
buildWindow: parentWindow
        "Private - Create the window for the receiver
         using parentWindow as the parent."
    | ps |
    style isNil ifTrue: [ style := self getStyle].
    self create: self winClass
        title: self initialText
        style:  style
        rectangle: (0@0 extent: 0@0)
        parent: self parent.
    handle = NullHandle ifTrue: [^nil].
    curFont isNil ifTrue: [curFont := self defaultFont].
    self initGraphics.
    self receiveMessages.
    children size ~= 0
        ifTrue: [
            children do: [:each |
                (each buildWindow: self) isNil ifTrue:[self close.^nil]]]! 
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
    ^WsBorder |
        WsHscroll |
        WsVscroll |
        WsClipsiblings!
isSubPane
        "Answer whether the receiver is a kind of SubPane."
    ^true!  !

!SystemDictionary methods !  
version
        "Answer the version number as a string"
    ^'2.0.4'! !

!Window class methods !  
disablePaletteMessages
    " Window disablePaletteMessages "
    WinEvents at:783 put:  nil.
    WinEvents at:784 put:  nil.
    WinEvents at:785 put:  nil!  
enablePaletteMessages
    " Window enablePaletteMessages "
    ( GDIDLL canUnderstand: #updateColors: ) ifFalse: [ ^self error: 'Better not do this' ].
    ( self canUnderstand: #wmQuerynewpalette:with: )
        ifTrue: [ WinEvents at:783 put:  #wmQuerynewpalette:with: ].
    ( self canUnderstand: #wmPaletteischanging:with: )
        ifTrue: [ WinEvents at:784 put:  #wmPaletteischanging:with: ].
    ( self canUnderstand: #wmPalettechanged:with: )
        ifTrue: [ WinEvents at:785 put:  #wmPalettechanged:with: ]! !

!Window methods !
addStyle: styleBits
        "Private - if style is nil, initialize it appropriately:
         if #noDefaultStyle was previously sent to the receiver,
         set it to 0, otherwise set it to defaultStyle; then add the
         given style bits to the flag.  Answer the added styleBits."
    style isNil ifTrue: [ style := self getStyle ].
    style := style | styleBits.
    ^style!
basicStyle
        "Private - Answer the basic host window style for the receiver."
    ^WsVisible! 
defaultStyle
        "Private - Answer the specific style flags which
         define special characteristics of this window;
         usually reimplemented in subclasses."
    ^0!  
getStyle
        "Answer the initial style of the receiver, composed of
       its basicStyle and its defaultStyle."
    ^self basicStyle | self defaultStyle! 
hasStyle: aStyle
        "Answer whether the receiver has the specified bits set in
        its style flag."
    | flags |
    flags := style isNil ifTrue: [ self getStyle ] ifFalse: [ style ].
    ^( flags bitAnd: aStyle ) = aStyle!
hideWindow
        "Make the receiver invisible."
    self frameWindow removeStyle: WsVisible.
    self isHandleOk ifTrue: [ self frameWindow handle hideWindow ]! 
isHidden
       "Answer whether the receiver is hidden."
    ^( self frameWindow hasStyle: WsVisible ) not! 
removeStyle: styleBits
        "Private - if style is nil, initialize it appropriately:
         if #noDefaultStyle was previously sent to the receiver,
         set it to 0, otherwise set it to defaultStyle; then remove
         the given style bits from the flag.  Answer the removed
         styleBits."
    | mask |
    style isNil ifTrue: [ style := self getStyle ].
    mask := styleBits bitXor: 16rFFFFFFFF.
    style := style bitAnd: mask.
    ^styleBits! 
showWindow
        "Make the receiver visible."
    self frameWindow addStyle: WsVisible.
    self isHandleOk ifTrue: [ self frameWindow handle showWindow ]!    !

!MDIChild methods !  
buildWindow
        "Private - Create the document for the receiver."
        "see Microsoft online Q70080 Creating a Hidden MDI Child Window."

    | mdiCreate answer max winaddress m |
    max := self frame mdiIsMaximized.
    NewWindow notNil ifTrue: [ ^nil ].
    self frame isActive ifFalse: [
        self frame makeActive.
        self frame updateWindow ].

    "Prevent redraw during creation of child window so that child window will
    not flash on screen when it is created then hidden."
    self parent noRedraw: true.

    style isNil ifTrue: [ style := self getStyle ].
    mdiCreate:=WinMdiCreateStruct new.
    mdiCreate szTitle: self label.
    mdiCreate szClass: self winClass.
    mdiCreate hOwner: self dsHandle.
    mdiCreate x: rectangle origin x asInteger.
    mdiCreate y: rectangle origin y asInteger.
    mdiCreate cx: rectangle width asInteger.
    mdiCreate cy: rectangle height asInteger.
    mdiCreate style: style.
    mdiCreate lParam: NullHandle.
    winaddress := WinAddress copyToNonSmalltalkMemory: mdiCreate asParameter.
    NewWindow := self.
    answer := WinStructure fromBytes:
        (UserLibrary
            sendMessage: self parent asParameter
            msg: WmMdicreate
            wparam: 0
            lparam: winaddress asParameter).
    NewWindow := nil.
    mdiCreate free.
    winaddress unlockAndFree.
    handle := WindowHandle fromInteger: (answer uShortAtOffset: 0).
    handle = NullHandle ifTrue: [
        self panicWmMdiCreate.
        ^nil].
    self frame renumber: self.
    "Set the size of the frame window."
    rectangle := self rectangle.

    m := UserLibrary
            getSystemMenu: self asParameter
            revert: 0.
    self propertyAt: #sysMenu put: m.

    self activeTextPane: self searchForDefaultTextPane.

    "Prevent redraw during creation of child window so that child window
    will not flash on screen when it is created then hidden."
    self frameWindow handle hideWindow.

    (max and: [ self isHidden not ]) ifTrue: [ self showMaximizedWindow ].!   
closeView
        "Private - Close the receiver and all its children."

    | answer active max |
    self isHandleOk ifFalse: [ ^self ]. "already closed"

    "Temporarilly prevent the MDIClient from redrawing
    while we close the receiver. This prevents an annoying flicker when the
    receiver is maximized and the next MDIChild in sequence is maximized
    to take its place. This code was previously in #hideWindow where it had
    ill side-effects (documented therein). In addition, it did not even work
    correctly to prevent the aforementioned flicker."
    (max := self frame mdiIsMaximized) ifTrue: [
            self parent noRedraw: true ].

    answer := super closeView.
    answer isNil ifTrue: [ ^nil ].

    "Modified by DMZ, OSI 2/27/97 to only disconnect the
    receiver from its owner if there is a single, master view
    manager that is in charge of the main MDI window and
    its children. If the receiver has its own manager, we want
    the manager's connection to remain so it can perform any
    necessary cleanup in its #closed handler. Note, that non-MDI
    multi-view ViewManagers do not have their view automatically
    disconnected when they close."
    #modifiedByOSI.
    "owner removeView: self."
    (owner == self frame owner and: [ owner respondsTo: #removeView: ])
        ifTrue: [ owner removeView: self ].

    self frame childClose.
    self frame renumber: self.
    active :=self frame mdiGetActive.
    active isNil ifTrue: [ self setInitMenu ].
    max ifTrue: [ self updateClient ].
    ^answer!  
updateClient
        "Private- Update the MDI client."
    | active |
    self parent noRedraw: false.
    "The MDIClient has redraw disabled, both when the
    receiver is initially created by #buildWindow, and when the receiver
    is closed. In the former case, this method is called when the receiver
    is validated and in the latter case, after the receiver is destroyed. The
    purpose is to reenable and refresh the MDIClient with its new contents.
    Under these circumstances, we need to refresh the following:

        1. The MDIClient's client area. This is particularlly important when the
            receiver is being closed.
        2. The receiver's complete client and non-client areas when the receiver
            is being built.
        3. The non-client areas of all of the other MDI children. This ensures
             that the active and inactive children have their title bars painted properly."

    "Force a repaint of the MDIClient's client area."
    self parent invalidateRect: nil.

    "Force a repaint of the receiver's complete client and
    non-client areas."
    self isHandleOk ifTrue: [
        UserLibrary
            redrawWindow: self asParameter
            rectangle: nil
            region: nil
            redraw: RdwInvalidate | RdwErase | RdwFrame | RdwAllchildren ].

    "Update each sibling's non-client area."
    active := self frame mdiGetActive.
    self frame mdiChildren do: [ :each |
        (each ~~ self and: [ each isHandleOk ]) ifTrue: [
            UserLibrary
                sendMessage: each asParameter
                msg: WmNcactivate
                wparam: (each == active ifTrue: [ 1 ] ifFalse: [ 0 ])
                lparam: 0 ]].! 
validate
        "Private - Create or recreate the window for the receiver."
    | old answer |
    self parent isHandleOk ifFalse: [ ^nil ].

    "Do not want to receive messages in MDIClient while in buildWindow"
    old :=  Process enableInterrupts: false.

    answer := super validate.
    answer notNil ifTrue: [
        self isHidden ifFalse: [
            self frame mdiActivate:self ]].
    self updateClient.

    Process enableInterrupts: old.
    answer isNil ifTrue: [ ^nil ].

    self systemMenuItemClose
        ifFalse: [ self  disableSysMenu:6 ].
    MDISystem mdiSelected: true.!   !

!MDIClient methods ! 
basicStyle
        "Private - Answer an Integer with appropriate styles in it."
    ^WsHscroll
        | WsVscroll
        | WsChild
        | WsClipsiblings
        | WsClipchildren
        | WsVisible
        | MdisAllchildstyles!  
create: className
    title: nameString
    style: styleInteger
    rectangle: aRectangle
    parent: parentWindow
        "Private - Create a window in the host system whose parent is
         parentWindow with aTitleString and aFrameStyle.
         The receiver's handle is set to the
         resulting client window."

    | result parentHandle menuHandle clientCreateStruct addrClassName addrTitleName addrStruct |
    parentWindow notNil ifTrue: [ parentHandle := parentWindow handle ].
    (styleInteger bitAnd: WsChild) ~= 0 ifTrue: [ menuHandle := self id ].
    clientCreateStruct := WinClientCreateStruct new.
    clientCreateStruct hMenu: parentWindow menuWindow asParameter.
    clientCreateStruct idFirstChild: 100.
    addrClassName := WinAddress copyToNonSmalltalkMemory: className asParameter.
    nameString notNil ifTrue:[
        addrTitleName := WinAddress copyToNonSmalltalkMemory: nameString asParameter ].
    addrStruct:=WinAddress copyToNonSmalltalkMemory: clientCreateStruct asParameter.
    result := UserLibrary
        createWindow: addrClassName asParameter
        name: addrTitleName asParameter
        style: styleInteger
        x: aRectangle origin x
        y: aRectangle origin y
        width: aRectangle width
        height: aRectangle height
        parent: parentHandle
        menu: menuHandle
        instance: self dsHandle
        param: addrStruct asParameter.
    handle := WindowHandle fromInteger: result.

    addrStruct unlockAndFree.
    addrClassName unlockAndFree.
    addrTitleName notNil ifTrue: [
        addrTitleName unlockAndFree ].
    result = 0 ifTrue: [ ^nil ].
    UserLibrary setWindowWord: self parent asParameter index: 0 word: self asParameter.!    !

!StatusPane methods !
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
     ^WsChild |
        WsClipchildren |
        WsClipsiblings!  !

!ToolPane methods !  
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
     ^WsChild |
        WsClipsiblings |
        WsBorder!    !

!CompositePane methods ! 
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
    ^0! !

!DialogTopPane methods ! 
buildItems
    "Modified by OSI to support framing parameters
        and support extra dialog item template data."
        "Private - Build the control items within
         the dialog box.  Answer an array of item
         templates."
    | answer rect text extraData |
    #modifiedByOSI.
    answer := OrderedCollection new.
    children do: [ :subpane |
        subpane style isNil ifTrue: [ subpane style: subpane getStyle ].
        "OSI - replaced #isKindOf: tests for SubPane and Rectangle"
        (subpane isSubPane) ifTrue: [
            (rect := subpane framingBlock) isRectangle not
                ifTrue: [rect := rect value: (0@0 extent: rectangle extent)].
            text := subpane initialText.
            text isString ifFalse:[
                text := nil].
            answer add: (
                (extraData := subpane extraDialogItemData) isNil
                    ifTrue: [
                        WinDialogInfo
                            itemTemplateStyle: subpane style
                            x: rect left
                            y: rect top
                            cx: rect extent x
                            cy: rect extent y
                            id: subpane id
                            className: subpane winClass
                            text: text ]
                    ifFalse: [
                        WinDialogInfo
                            itemTemplateStyle: subpane style
                            x: rect left
                            y: rect top
                            cx: rect extent x
                            cy: rect extent y
                            id: subpane id
                            className: subpane winClass
                            text: text
                            extraData: extraData ] ).
            subpane initSize: rect ]].
    ^answer!   
buildWindow: aParentWindow
        "Private - Create the dialog window for the receiver."

    | winDlgTemplate items winDlgFontInfo tempByteArray m pDlgTemplate|

    "Modified by OSI to add #initWindow code, to
    avoid parent being nil for framingblock, and to
    add #sizeWindow call."
    #modifiedByOSI.

    style isNil ifTrue: [ style := self getStyle ].
    framingBlock isNil
        ifTrue: [
            rectangle := self initSize.
            framingBlock := rectangle]
        ifFalse: [rectangle := framingBlock value: (parent isNil ifFalse: [ parent rectangle] ifTrue: [ Display boundingBox ]) ].

    NewWindow notNil ifTrue: [
        NewWindow := nil.
        Terminal bell.
        ^self ].
    NewWindow := self.
    winDlgTemplate := WinDialogInfo
        dialogTemplateStyle: style
        itemCount: 0
        x: rectangle origin x
        y: rectangle origin y
        cx: rectangle extent x
        cy: rectangle extent y
        menuName: nil
        className: nil
        text: label.
    winDlgFontInfo := WinDialogInfo         "not used yet"
        fontPointSize: 0 typeFaceName: nil.
    items := self buildItems.
    winDlgTemplate byteAtOffset: 4 put: items size.
    tempByteArray := winDlgTemplate contents.
    items do: [ :i |
        tempByteArray := tempByteArray, i contents ].
    winDlgTemplate contents: tempByteArray.

    "OSI - Folded in fix made by Digitalk"
    pDlgTemplate := WinAddress copyToNonSmalltalkMemory: winDlgTemplate contents.
    handle := WindowHandle fromInteger: (
        UserLibrary
            createDialogIndirect: WIN hInstanceExe
            dialogTemplate: pDlgTemplate asParameter
            parent: parent asParameter
            dialogFunction:
                (WinLong fromBytes: DialogProcInstance) asParameter).
    pDlgTemplate free.

    handle = NullHandle ifTrue: [^self error: 'Dialog creation error'].
    self initGraphics.
    self receiveMessages.
    NewWindow := nil.
    self buildDialogItems.
    children do: [ :subpane | subpane validate ].

    owner initWindow.
    self sizeWindow.

    m := UserLibrary
            getSystemMenu: self asParameter
            revert: 0.
    self propertyAt: #sysMenu put: m.
    PoppedModelessWindows add: handle.
    self showWindow.!   !

!Object methods !
dialogTemplate
    "Added by OSI"
    #addedByOSI.
    ^nil!   
dialogTemplate: ignore
    "Added by OSI"
    #addedByOSI.
    ^self!    !

!WBToolBar methods ! 
affectsFreeClientArea
    "Private - Answer whether the receiver reduces the amount of
    free client area in its parent for the receiver's siblings."

    ^self isMDISupportPane!  
isMDISupportPane
        "Answer true if receiver is a support pane for MDI."
    ^self tpStyle == #mdiToolBar!   !

"evaluate"   
(File pathName: 'se204up\install.st') fileIn; close!

"evaluate"
""*** saved image on: Jul 29, 2005 22:41:29 ***""!

"evaluate"  
5 + 6!

"evaluate"  
20 factorial!

"evaluate"   
'Esto es una prueba' size!

"evaluate"  
#( 1 3 5 7 ) at:2!

"evaluate"  
'Paradigmas' isArray!

"evaluate"   
5*7!

"evaluate"
5 // 2!

"evaluate" 
4 \\ 3!

"evaluate" 
2 / 6!

"evaluate"  
1.5 + 6.3e2!

"evaluate"
Array new!

"evaluate"  
Date today!

"evaluate" 
Time now!

"evaluate"   
#('arreglo' 'de' 'string')size!

"evaluate" 
'hoy es jueves' asUpperCase!

"evaluate"
'hola aqui estoy'reversed!

"evaluate"  
#(4 'cinco' 6 7 ) reversed!

"evaluate" 
$A asciiValue!

"evaluate"  
65 asCharacter!

"evaluate" 
'Cual es la longitud de esta oracion' size!

"evaluate" 
'hola', 'aqui estoy'!

"evaluate"   
#(1 2 3),#(4 5 6)!

"evaluate"  
4=5!

"evaluate"
#(1 2 $a), #($b 'cd')!

"evaluate"  
'Esto es una prueba' at:3!

"evaluate"  
'Hola' includes: $o!

"evaluate"
'hola' at:1 put:$H!

"evaluate" 
'Paradigmas de Programacion' copyFrom: 4 to: 9!

"evaluate" 
#(9 8 7 6 5) at:3!

"evaluate"  
#( 1 ( 2 3 ) 4 5 ) includes: #( 2 3 )!

"evaluate"  
#( 9 8 7 6 5) copyFrom: 1 to:2!

"evaluate" 
Array new:10!

"evaluate"   
'hola' size + 4!

"evaluate"
'ahora' size + #( 1 2 3 4 ) size!

"evaluate"   
#( 1 12 24 36 ) includes: 4 factorial!

"evaluate"  
3 + 4  *  2!

"evaluate"
3 + ( 4 * 2 )!

"evaluate"  
4 factorial between: 3 + 4 and: 'hola' size * 7!

"evaluate"
'hola' at: ( #( 5 3 1 ) at:2 )!

"evaluate" 
Array with: 1 with: 'hola' with: (1/3)!

"evaluate" 
Display!

"evaluate"
Transcript!

"evaluate" 
Disk!

"evaluate"   
3 < 4!

"evaluate"  
#( 1 2 3 4 ) = #( 1 2 3 4)!

"evaluate" 
5 = ( 2 + 3 )!

"evaluate"  
[ $a isVowel ] value!

"evaluate"   
[ $b isVowel ] value!

"evaluate"   
[ 3 + 4.'hola'  asUpperCase ] value!

"evaluate"
| bloque |
bloque := ['Hola' , 'Como estas?'].
   ^bloque value!

"evaluate"  
[ :c | c isVowel ] value: $a!

"evaluate"   
[ :c | c isVowel ] value: $b!

"evaluate"   
| bloque resp |
  bloque:=[ :a :b | a , b ].
  resp:= bloque value: 'hola'  value: 'como estas?'.
  ^resp!

"evaluate"   
5 < 2 or: [ $a isVowel ]!

"evaluate"   
5 < 2!

"evaluate"  
( 5 < 2 ) not!

"evaluate"  
5 < 2 and: [$a isVowel]!

"evaluate"
( 5 < 2 ) not and: [ $a isVowel ]!

"evaluate"  
( 5 < 2 ) not or: [ 'hola' size < 2 and: [ $a isVowel ] ]!

"evaluate"  
#(Francesca Jackie Marisa Bree) class!

"evaluate"  
'Rakesh Vijay Charles Daniel Tyler' class!

"evaluate"  
5 class!

"evaluate"
(1/2) class!

"evaluate"
5.2 class!

"evaluate"  
3 factorial; factorial ; factorial!

"evaluate" 
3 factorial factorial factorial!

"evaluate"
| a |
a := #( 1 2 sam 'joe' ( 4 5 ) ).
a at: 2 put: 3 / 4.
a inspect!

"evaluate"
3 > 4 ifTrue: [ ' el bloque verdadero ' ]
             ifFalse: ['el bloque falso' ]!

"evaluate"  
( 5 > 2 ) ifTrue:[ ^ '5 es mayor que 2 ']
                 ifFalse:[^ '5 es menor que 2'].!

"evaluate"
$b isVowel ifTrue:[^'es una vocal']
                      ifFalse:[^'es una consonante'].!

"evaluate" 
| f g resto cociente |

f:= Prompter prompt: 'jojojoj ' default:''.!

"evaluate"  
| f g resto cociente |

f:= ( Prompter prompt: 'Ingrese dividendo  ' default:'') asInteger.
g:= ( Prompter prompt: 'Ingrese divisor' default:'') asInteger.
cociente:=1.
[f > g] whileTrue:[
  f:= f  - g.
 cociente:= cociente + 1.



]. ^f!

"evaluate"   
| f g resto cociente |

f:= ( Prompter prompt: 'Ingrese dividendo  ' default:'') asInteger.
g:= ( Prompter prompt: 'Ingrese divisor' default:'') asInteger.
resto:=1.
[f > g] whileTrue:[
  f:= f  - g.
 resto:= resto + 1.



].!

"evaluate"   
| f g resto cociente |

f:= ( Prompter prompt: 'Ingrese dividendo  ' default:'') asInteger.
g:= ( Prompter prompt: 'Ingrese divisor' default:'') asInteger.
resto:=1.
[f > g] whileTrue:[
  f:= f  - g.
 resto:= resto + 1.



].
 MessageBox message:'coso',resto asString.!

"evaluate"   
| f g resto cociente |

f:= ( Prompter prompt: 'Ingrese dividendo  ' default:'') asInteger.
g:= ( Prompter prompt: 'Ingrese divisor' default:'') asInteger.
resto:=1.
[f > g] whileTrue:[
  f:= f  - g.
 resto:= resto + 1.



].
 MessageBox message:'el cociente es: ',f asString , ' el resto es: ' ,resto asString.!

"evaluate"
| f g resto cociente |

f:= ( Prompter prompt: 'Ingrese dividendo  ' default:'') asInteger.
g:= ( Prompter prompt: 'Ingrese divisor' default:'') asInteger.
resto:=1.
[f > g] whileTrue:[
  f:= f  - g.
 resto:= resto + 1.



].
 MessageBox message:'el cociente es: ',f asString , ' el resto es: ' ,resto asString.!

"evaluate"
| f g resto cociente |

f:= ( Prompter prompt: 'Ingrese dividendo  ' default:'') asInteger.
g:= ( Prompter prompt: 'Ingrese divisor' default:'') asInteger.
resto:=0.
[f > g] whileTrue:[
  f:= f  - g.
 resto:= resto + 1.



].
 MessageBox message:'el cociente es: ',f asString , ' el resto es: ' ,resto asString.!

"evaluate"
| f g suma |

f:= (Prompter prompt:'Ingrese multiplicando ' default:'' ) asInteger.
g:= (Prompter prompt:'ingrese multiplicador' default:'') asInteger.
suma:=0.
 1 to: ( g ) do:[:i |  suma:=suma + f. ].^suma!

"evaluate"   
| f g suma |

f:= (Prompter prompt:'Ingrese multiplicando ' default:'' ) asInteger.
g:= (Prompter prompt:'ingrese multiplicador' default:'') asInteger.
suma:=0.
 1 to: ( g ) do:[:i |  suma:=suma + f. ].
MessageBox message:'el producto es: ', suma asString.!

"evaluate" 
| ingreso prueba |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.!

"evaluate"
| ingreso prueba |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.

1 to: (ingreso) do:[:i| prueba:= (ingreso // i).].^prueba!

"evaluate"   
| ingreso prueba sum |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.
sum:=0.
1 to: (ingreso) do:[:i| prueba:= (ingreso // i). (prueba==0) ifTrue:[ sum:= sum + 1].].^sum!

"evaluate"  
| ingreso prueba sum |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.
sum:=0.
1 to: (ingreso) do:[:i| prueba:= (ingreso // i). (prueba=0) ifTrue:[ sum:= sum + 1].].!

"evaluate"   
| ingreso prueba sum |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.
sum:=0.
1 to: (ingreso) do:[:i| prueba:= (ingreso // i). (prueba=0) ifTrue:[ sum:= sum + 1].].!

"evaluate"   
| ingreso prueba sum |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.
sum:=0.
1 to: (ingreso) do:[:i| prueba:= (ingreso // i). (prueba=0) ifTrue:[ sum:= sum + 1].].^sum!

"evaluate"   
| ingreso prueba sum |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.
sum:=0.
1 to: (ingreso) do:[:i| prueba:= (ingreso \\ i). (prueba=0) ifTrue:[ sum:= sum + 1].].^sum!

"evaluate"   
| ingreso prueba sum |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.
sum:=0.
1 to: (ingreso) do:[:i| prueba:= (ingreso \\ i). (prueba=0) ifTrue:[ sum:= sum + 1].].
(sum=2) ifTrue:[ MessageBox message:'el numero :',ingreso asString  , 'es primo']
               ifFalse:[ MessageBox message:' el numero :' , ingreso asString , ' no es primo'].!

"evaluate"  
| ingreso prueba sum |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.
sum:=0.
1 to: (ingreso) do:[:i| prueba:= (ingreso \\ i). (prueba=0) ifTrue:[ sum:= sum + 1].].
(sum=2) ifTrue:[ MessageBox message:'el numero ',ingreso asString  , 'es primo']
               ifFalse:[ MessageBox message:' el numero ' , ingreso asString , ' no es primo'].!

"evaluate"
| ingreso prueba sum |

ingreso:=(Prompter prompt:'ingrese un numero para determinar si es primo o no' default:'') asInteger.
sum:=0.
1 to: (ingreso) do:[:i| prueba:= (ingreso \\ i). (prueba=0) ifTrue:[ sum:= sum + 1].].
(sum=2) ifTrue:[ MessageBox message:'el numero ',ingreso asString  , 'es primo']
               ifFalse:[ MessageBox message:' el numero ' , ingreso asString , ' no es primo'].!

"evaluate"
| ingreso prueba |

ingreso:= ( Prompter prompt:' Ingrese un numero para determinar si es par o no' default:'') asInteger.
((ingreso \\ 2)=0) ifTrue:[MessageBox message:' es par']
                           ifFalse:[MessageBox message:'no es par'].!

"evaluate"   
| ingreso prueba |

ingreso:= ( Prompter prompt:' Ingrese un numero para determinar si es par o no' default:'') asInteger.
((ingreso \\ 2)=0) ifTrue:[MessageBox message:' es par']
                           ifFalse:[MessageBox message:'no es par'].!

"evaluate"   
| ingreso prueba |

ingreso:= ( Prompter prompt:' Ingrese un numero para determinar si es par o no' default:'') asInteger.
((ingreso \\ 2)=0) ifTrue:[MessageBox message:'el numero', ingreso asString, ' es par']
                           ifFalse:[MessageBox message:'el numero', ingreso asString, 'no es par'].!

"evaluate" 
| ingreso prueba lista|

ingreso:= ( Prompter prompt: 'Ingrese un numero para determinar sus multiplos' default:'') asInteger.
lista:= Set new.!

"evaluate" 
| ingreso prueba lista|

ingreso:= ( Prompter prompt: 'Ingrese un numero para determinar sus multiplos' default:'') asInteger.
lista:= Set new.

1 to: (ingreso) do:[:i| prueba:= (ingreso \\ i). ( prueba=0) ifTrue:[ lista add: i ].].^lista!

"evaluate"
| ingreso prueba lista|

ingreso:= ( Prompter prompt: 'Ingrese un numero para determinar sus multiplos' default:'') asInteger.
lista:= Set new.

1 to: (ingreso) do:[:i| prueba:= (ingreso \\ i). ( prueba=0) ifTrue:[ lista add: i ].].
MessageBox message:'los multiplos son', lista asString.!

"evaluate" 
| ingreso prueba lista|

ingreso:= ( Prompter prompt: 'Ingrese un numero para determinar sus multiplos' default:'') asInteger.
lista:= Set new.

1 to: (ingreso) do:[:i| prueba:= (ingreso \\ i). ( prueba=0) ifTrue:[ lista add: i ].].
MessageBox message:'los multiplos son', lista asString.!

"evaluate" 
| ingreso coso1 coso2 seguir |

[ seguir ~= 'no'] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese algo' default:'').



                                              ].!

"evaluate" 
| ingreso coso1 coso2 seguir |

[ seguir ~= 'no'] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'') .



                                              ].!

"evaluate"   
| lista2 lista3 lista5 lista7 seguir prueba2 prueba3 prueba5 prueba7 |

 lista2:= Set new.
  lista3:= Set new.
 lista5:= Set new.
 lista7:= Set new.


[ seguir ~= 'no'] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'') .
    prueba2:= seguir asInteger \\ 2.  prueba3:= seguir asInteger  \\ 3.      prueba5:= seguir asInteger  \\ 5.      prueba7:= seguir asInteger \\ 7.

    (prueba2=0) ifTrue:[ lista2 add:seguir ].
     (prueba3=0) ifTrue:[ lista3 add:seguir ].
      (prueba5=0) ifTrue:[ lista5 add:seguir ].
       (prueba7=0) ifTrue:[ lista7 add:seguir ].                                        ]. ^lista2!

"evaluate"  
| lista2 lista3 lista5 lista7 seguir prueba2 prueba3 prueba5 prueba7 |

 lista2:= 0.
  lista3:= 0.
 lista5:= 0.
 lista7:= 0.


[ seguir ~= 'no'] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'') .
    prueba2:= seguir asInteger \\ 2.  prueba3:= seguir asInteger  \\ 3.      prueba5:= seguir asInteger  \\ 5.      prueba7:= seguir asInteger \\ 7.

    (prueba2=0) ifTrue:[ lista2 := lista2 + 1 ].
     (prueba3=0) ifTrue:[ lista3 := lista3 + 1  ].
      (prueba5=0) ifTrue:[ lista5 := lista5 + 1  ].
       (prueba7=0) ifTrue:[ lista7 :=lista7 +1  ].                                        ].^lista2!

"evaluate"  
| lista2 lista3 lista5 lista7 seguir prueba2 prueba3 prueba5 prueba7 |

 lista2:= 0.
  lista3:= 0.
 lista5:= 0.
 lista7:= 0.


[ seguir ~= 'no'] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'') .
    prueba2:= seguir asInteger \\ 2.  prueba3:= seguir asInteger  \\ 3.      prueba5:= seguir asInteger  \\ 5.      prueba7:= seguir asInteger \\ 7.

    (prueba2=0) ifTrue:[ lista2 := lista2 + 1 ].
     (prueba3=0) ifTrue:[ lista3 := lista3 + 1  ].
      (prueba5=0) ifTrue:[ lista5 := lista5 + 1  ].
       (prueba7=0) ifTrue:[ lista7 :=lista7 +1  ].                                        ].^lista2!

"evaluate"  
| lista2 lista3 lista5 lista7 seguir prueba2 prueba3 prueba5 prueba7 |

 lista2:= 0.
  lista3:= 0.
 lista5:= 0.
 lista7:= 0.


[ seguir ~= 'no'] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'') .
    prueba2:= seguir asInteger \\ 2.  prueba3:= seguir asInteger  \\ 3.      prueba5:= seguir asInteger  \\ 5.      prueba7:= seguir asInteger \\ 7.

    (prueba2=0) ifTrue:[ lista2 := lista2 + 1 ].
     (prueba3=0) ifTrue:[ lista3 := lista3 + 1  ].
      (prueba5=0) ifTrue:[ lista5 := lista5 + 1  ].
       (prueba7=0) ifTrue:[ lista7 :=lista7 +1  ].                                        ].^lista2!

"evaluate"  
| lista2 lista3 lista5 lista7 seguir prueba2 prueba3 prueba5 prueba7 |

 lista2:= 0.
  lista3:= 0.
 lista5:= 0.
 lista7:= 0.


[ seguir ~= 'no'] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'') .
    prueba2:= seguir asInteger \\ 2.  prueba3:= seguir asInteger  \\ 3.      prueba5:= seguir asInteger  \\ 5.      prueba7:= seguir asInteger \\ 7.

    (prueba2=0) ifTrue:[ lista2 := lista2 + 1 ].
     (prueba3=0) ifTrue:[ lista3 := lista3 + 1  ].
      (prueba5=0) ifTrue:[ lista5 := lista5 + 1  ].
       (prueba7=0) ifTrue:[ lista7 :=lista7 +1  ].                                        ].^lista2!

"evaluate"  
| lista2 lista3 lista5 lista7 seguir prueba2 prueba3 prueba5 prueba7 |

 lista2:= 0.
  lista3:= 0.
 lista5:= 0.
 lista7:= 0.


[ seguir ~= 'no'] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'') .
    prueba2:= seguir asInteger \\ 2.  prueba3:= seguir asInteger  \\ 3.      prueba5:= seguir asInteger  \\ 5.      prueba7:= seguir asInteger \\ 7.

    (prueba2==0) ifTrue:[ lista2 := lista2 + 1 ].
     (prueba3=0) ifTrue:[ lista3 := lista3 + 1  ].
      (prueba5=0) ifTrue:[ lista5 := lista5 + 1  ].
       (prueba7=0) ifTrue:[ lista7 :=lista7 +1  ].                                        ].^lista2!

"evaluate" 
| lista2 lista3 lista5 lista7 seguir prueba2 prueba3 prueba5 prueba7 |

 lista2:= 0.
  lista3:= 0.
 lista5:= 0.
 lista7:= 0.


[ seguir ~= 0 ] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'')  asInteger.
    prueba2:= seguir  \\ 2.  prueba3:= seguir   \\ 3.      prueba5:= seguir   \\ 5.      prueba7:= seguir  \\ 7.

    (prueba2==0) ifTrue:[ lista2 := lista2 + 1 ].
     (prueba3=0) ifTrue:[ lista3 := lista3 + 1  ].
      (prueba5=0) ifTrue:[ lista5 := lista5 + 1  ].
       (prueba7=0) ifTrue:[ lista7 :=lista7 +1  ].                                        ].^lista2!

"evaluate" 
| lista2 lista3 lista5 lista7 seguir prueba2 prueba3 prueba5 prueba7 |

 lista2:= 0.
  lista3:= 0.
 lista5:= 0.
 lista7:= 0.


[ seguir ~= 0 ] whileTrue:
[

    seguir:=( Prompter prompt:'ingrese un numero o para terminar escriba no ' default:'')  asInteger.
    prueba2:= seguir  \\ 2.  prueba3:= seguir   \\ 3.      prueba5:= seguir   \\ 5.      prueba7:= seguir  \\ 7.

    (prueba2==0) ifTrue:[ lista2 := lista2 + 1 ].
     (prueba3=0) ifTrue:[ lista3 := lista3 + 1  ].
      (prueba5=0) ifTrue:[ lista5 := lista5 + 1  ].
       (prueba7=0) ifTrue:[ lista7 :=lista7 +1  ].                                        ].^lista2!

"evaluate" 
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= Set new.


 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].!

"evaluate" 
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( lista size ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso) ifTrue:[ MessageBox message:' coso '.].!

"evaluate"  
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( lista size ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso) ifTrue:[ MessageBox message:' coso '.].!

"evaluate"  
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso) ifTrue:[ MessageBox message:' coso '.].!

"evaluate"  
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso) ifTrue:[ MessageBox message:' coso '.].!

"evaluate"  
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso) ifTrue:[ MessageBox message:' coso '.].!

"evaluate"  
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso) ifTrue:[ MessageBox message:' coso '.].!

"evaluate"  
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso) ifTrue:[ MessageBox message:' el numero  ', ingreso asString , ' es perfecto' .].!

"evaluate"
| ingreso prueba suma lista |

ingreso:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

 1 to: ingreso do:[:i| prueba:= (ingreso \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso) ifTrue:[ MessageBox message:' el numero  ', ingreso asString , ' es perfecto' .]
                              ifFalse:[ MessageBox message:' el numero ', ingreso asString, 'no es perfecto'].!

"evaluate" 
| ingreso1 ingreso2   prueba suma lista |

ingreso1:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
ingreso2:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

1 to: ingreso1 do:[:i| prueba:= (ingreso1 \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso2) ifTrue:[ MessageBox message:' los numeros  ', ingreso1 asString , ' y' ,  ingreso2 asString , ' son amigos' .]
                              ifFalse:[ MessageBox message:' los numeros  ', ingreso1 asString , ' y' ,  ingreso2 asString , ' no  son amigos' .].!

"evaluate"  
| ingreso1 ingreso2   prueba suma lista |

ingreso1:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
ingreso2:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

1 to: ingreso1 do:[:i| prueba:= (ingreso1 \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso2)  ifTrue:[ MessageBox message:' los numeros  ', ingreso1 asString , ' y' ,  ingreso2 asString , ' son amigos' .]
                              ifFalse:[ MessageBox message:' los numeros  ', ingreso1 asString , ' y' ,  ingreso2 asString , ' no  son amigos' .].!

"evaluate" 
| ingreso1 ingreso2   prueba suma lista |

ingreso1:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
ingreso2:=(Prompter prompt:'ingrese un numero o para terminar escriba no' default:'') asInteger.
lista:= OrderedCollection new.
suma:=0.

1 to: ingreso1 do:[:i| prueba:= (ingreso1 \\ i ). (prueba=0) ifTrue:[ lista add: i ].].
  1 to: ( ( lista size ) - 1 ) do:[:i| suma:= suma + ( lista at:i ). ].
  (suma = ingreso2)  ifTrue:[ MessageBox message:' los numeros  ', ingreso1 asString , ' y' ,  ingreso2 asString , ' son amigos' .]
                              ifFalse:[ MessageBox message:' los numeros  ', ingreso1 asString , ' y' ,  ingreso2 asString , ' no  son amigos' .].!

"evaluate" 
| ingreso|
ingreso:=(Prompter prompt:'Ingrese texto' default:'') asArrayOfSubstrings.!

"evaluate" 
| ingreso coso |
ingreso:=(Prompter prompt:'Ingrese texto' default:'') .

 coso:=ingreso asUpperCase.^coso!

"evaluate"  
| ingreso coso |
ingreso:=(Prompter prompt:'Ingrese texto' default:'') .

 coso:=ingreso asUpperCase.^coso!

"evaluate"  
| ingreso coso |
ingreso:=(Prompter prompt:'Ingrese texto' default:'') .

 ingreso asUpperCase.!

"evaluate" 
|ingreso coso |
ingreso:=(Prompter prompt:'ingrese texto' default:'').
coso:=   Set new.

1 to: ( ingreso size ) do:[:i| ( (ingreso at:i) isLowerCase)ifTrue:[ coso add: ( ( ingreso at:i) asUpperCase).].].!

"evaluate"   
|ingreso coso |
ingreso:=(Prompter prompt:'ingrese texto' default:'').
coso:=   Set new.

1 to: ( ingreso size ) do:[:i| ( (ingreso at:i) isLowerCase)ifTrue:[ coso add: ( ( ingreso at:i) asUpperCase).].].^coso!

"evaluate"  
|ingreso coso |
ingreso:=(Prompter prompt:'ingrese texto' default:'').
coso:=   OrderedCollection new.

1 to: ( ingreso size ) do:[:i| ( (ingreso at:i) isLowerCase)ifTrue:[ coso add: ( ( ingreso at:i) asUpperCase).].].^coso!

"evaluate"
|ingreso coso |
ingreso:=(Prompter prompt:'ingrese texto' default:'').
coso:=   OrderedCollection new.

1 to: ( ingreso size)  do:[:i| ( (ingreso at:i) isLowerCase)ifTrue:[ coso add: ( ( ingreso at:i) asUpperCase).].].^coso!

"evaluate"
|ingreso coso |
ingreso:=(Prompter prompt:'ingrese texto' default:'').
coso:=   OrderedCollection new.

1 to: ( ingreso size)  do:[:i| ( (ingreso at:i) isLowerCase)ifTrue:[ coso add: ( ( ingreso at:i) asUpperCase).].
                                           ( (ingreso at:i) isUpperCase)ifTrue:[ coso add: ( ( ingreso at:i) asLowerCase).].].^coso!

"evaluate"  
|ingreso coso |
ingreso:=(Prompter prompt:'ingrese texto' default:'').
coso:=   OrderedCollection new.

1 to: ( ingreso size)  do:[:i| ( (ingreso at:i) isLowerCase)ifTrue:[ coso add: ( ( ingreso at:i) asUpperCase).].
                                           ( (ingreso at:i) isUpperCase)ifTrue:[ coso add: ( ( ingreso at:i) asLowerCase).].].^coso!

"evaluate"  
| ingreso coso cont |

ingreso:= (Prompter prompt:'ingrese texto' default:'').
cont:=0.
1 to: (ingreso size) do:[:i| ( ( ingreso at:i) isVowel) ifTrue:[ cont:=cont + 1. ].].^cont!

"evaluate" 
| ingreso coso cont |

ingreso:= (Prompter prompt:'ingrese texto' default:'').
cont:=0.
1 to: (ingreso size) do:[:i| ( ( ingreso at:i) isVowel) ifTrue:[ cont:=cont + 1. ].].^cont!

"evaluate" 
| ingreso coso cont |

ingreso:= (Prompter prompt:'ingrese texto' default:'').
cont:=0.
1 to: (ingreso size) do:[:i| ( ( ingreso at:i) isVowel) ifTrue:[ cont:=cont + 1. ].].^cont!

"evaluate" 
| ingreso coso cont |

ingreso:= (Prompter prompt:'ingrese texto' default:'').
cont:=0.
1 to: (ingreso size) do:[:i| ( ( ingreso at:i) isVowel) ifTrue:[ cont:=cont + 1. ].].^cont!

"evaluate" 
| multiplicando multiplicador |

multiplicando:= (Prompter prompt:'ingrese multiplicando' default:'' ) asInteger.
multiplicador:= (Prompter prompt:'ingrese multiplicando' default:'' ) asInteger.!

"evaluate"  
| prod multiplicando multiplicador |

multiplicando:= (Prompter prompt:'ingrese multiplicando' default:'' ) asInteger.
multiplicador:= (Prompter prompt:'ingrese multiplicando' default:'' ) asInteger.


   prod:=0.
1 to: (multiplicador) do:[:i| prod:= prod + multiplicando.].^prod!

"evaluate" 
| prod multiplicando multiplicador |

multiplicando:= (Prompter prompt:'ingrese multiplicando' default:'' ) asInteger.
multiplicador:= (Prompter prompt:'ingrese multiplicando' default:'' ) asInteger.


   prod:=0.
1 to: (multiplicador) do:[:i| prod:= prod + multiplicando.].

MessageBox message:'el resultado es: ', prod asString.!

"evaluate"
| prod multiplicando multiplicador |

multiplicando:= (Prompter prompt:'ingrese multiplicando' default:'' ) asInteger.
multiplicador:= (Prompter prompt:'ingrese multiplicando' default:'' ) asInteger.


   prod:=0.
1 to: (multiplicador) do:[:i| prod:= prod + multiplicando.].

MessageBox message:'el resultado es: ', prod asString.!

"evaluate"
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=0.
[ dividendo > divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ]!

"evaluate"   
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=0.
[ dividendo > divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ].
MessageBox message:'el cociente es', dividendo asString , 'es ', resto asString.!

"evaluate"
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=0.
[ dividendo >= divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ].
MessageBox message:'el cociente es', dividendo asString , 'es ', resto asString.!

"evaluate"   
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=1.
[ dividendo >= divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ].
MessageBox message:'el cociente es', dividendo asString , 'es ', resto asString.!

"evaluate"   
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=1.
[ dividendo >= divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ].
MessageBox message:'el cociente es', dividendo asString , 'es ', resto asString.!

"evaluate"   
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=1.
[ dividendo >= divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ].
MessageBox message:'el cociente es', resto asString , ' resto es ', dividendo asString.!

"evaluate"
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=1.
[ dividendo >= divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ].
MessageBox message:'el cociente es', dividendo asString , ' resto es ', resto asString.!

"evaluate"
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=1.
[ dividendo >= divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ].
MessageBox message:'el cociente es', resto asString , ' resto es ', dividendo asString.!

"evaluate"
| divisor dividendo cociente resto |

dividendo:= (Prompter prompt:'ingrese divisor' default:'') asInteger.
divisor:=(Prompter prompt:'ingrese dividendo' default:'')asInteger.

resto:=0.
[ dividendo >= divisor] whileTrue:[

                                          dividendo:=dividendo - divisor.
                                          resto:= resto + 1.
                                       ].
MessageBox message:'el cociente es', resto asString , ' resto es ', dividendo asString.!

"evaluate"
| base potencia mult|

base:=(Prompter prompt:'ingrese base' default:'') asInteger.
potencia:= (Prompter prompt:'ingrese potencia' default:'') asInteger.

mult:=1.

1 to: potencia do:[:i| mult:=mult*base.].^mult!

"evaluate" 
| base potencia mult|

base:=(Prompter prompt:'ingrese base' default:'') asInteger.
potencia:= (Prompter prompt:'ingrese potencia' default:'') asInteger.

mult:=1.

1 to: potencia do:[:i| mult:=mult*base.].

MessageBox message:' la potencia es ' , mult asString.!

"evaluate"
| sum numero determinar |

numero:=(Prompter prompt:'ingrese un numero para determinar si es primo o no es primo' default:'') asInteger.


1 to:(numero) do:[:i| sum:=0. determinar:= (numero \\ i). (determinar=0) ifTrue:[ sum:= sum + 1.].].!

"evaluate"   
| sum numero determinar |

numero:=(Prompter prompt:'ingrese un numero para determinar si es primo o no es primo' default:'') asInteger.


1 to:(numero) do:[:i| sum:=0. determinar:= (numero \\ i). (determinar=0) ifTrue:[ sum:= sum + 1.].].!

"evaluate"   
| sum numero determinar |

numero:=(Prompter prompt:'ingrese un numero para determinar si es primo o no es primo' default:'') asInteger.


1 to:(numero) do:[:i| sum:=0. determinar:= (numero \\ i). (determinar=0) ifTrue:[ sum:= sum + 1.].].
                                                 (sum=2) ifTrue:[MessageBox message:'el numero  ',numero asString , 'es primo']
                                                               ifFalse:[MessageBox message:'el numero ', numero asString, 'no es primo'].!

"evaluate"   
| sum numero determinar |

numero:=(Prompter prompt:'ingrese un numero para determinar si es primo o no es primo' default:'') asInteger.


1 to:(numero) do:[:i| sum:=0. determinar:= (numero \\ i). (determinar=0) ifTrue:[ sum:= sum + 1.].].
                                                 (sum=2) ifTrue:[MessageBox message:'el numero  ',numero asString , 'es primo']
                                                               ifFalse:[MessageBox message:'el numero ', numero asString, 'no es primo'].!

"evaluate"   
| sum numero determinar |

numero:=(Prompter prompt:'ingrese un numero para determinar si es primo o no es primo' default:'') asInteger.

sum:=0.
1 to:(numero) do:[:i|  determinar:= (numero \\ i). (determinar=0) ifTrue:[ sum:= sum + 1.].].
                                                 (sum=2) ifTrue:[MessageBox message:'el numero  ',numero asString , 'es primo']
                                                               ifFalse:[MessageBox message:'el numero ', numero asString, 'no es primo'].!

"evaluate"   
| sum numero determinar |

numero:=(Prompter prompt:'ingrese un numero para determinar si es primo o no es primo' default:'') asInteger.

sum:=0.
1 to:(numero) do:[:i|  determinar:= (numero \\ i). (determinar=0) ifTrue:[ sum:= sum + 1.].].
                                                 (sum=2) ifTrue:[MessageBox message:'el numero  ',numero asString , 'es primo']
                                                               ifFalse:[MessageBox message:'el numero ', numero asString, 'no es primo'].!

"evaluate"   
| sum numero determinar |

numero:=(Prompter prompt:'ingrese un numero para determinar si es par o no es impar' default:'') asInteger.


determinar:= (numero \\ 2).
                                                 (determinar=0) ifTrue:[MessageBox message:'el numero  ',numero asString , 'es par']
                                                               ifFalse:[MessageBox message:'el numero ', numero asString, 'no es impar'].!

"evaluate" 
| sum numero determinar |

numero:=(Prompter prompt:'ingrese un numero para determinar si es par o no es impar' default:'') asInteger.


determinar:= (numero \\ 2).
                                                 (determinar=0) ifTrue:[MessageBox message:'el numero  ',numero asString , 'es par']
                                                               ifFalse:[MessageBox message:'el numero ', numero asString, 'no es impar'].!

"evaluate" 
""*** saved image on: Aug 17, 2018 23:33:58 ***""!

"evaluate"  
| numero determinar |

 numero:= (Prompter prompt:'Ingrese un numero ' default:'') asInteger.

 1 to: (numero) do:[:i| determinar:= (numero \\ i). (determinar=0) ifTrue:[ MessageBox message:'el numero ', i asString, ' es multiplo de ', numero asString]. ].!

"evaluate"   
| numero determinar |

 numero:= (Prompter prompt:'Ingrese un numero ' default:'') asInteger.

 1 to: (numero) do:[:i| determinar:= (numero \\ i). (determinar=0) ifTrue:[ MessageBox message:'el numero ', i asString, ' es multiplo de ', numero asString]. ].!

"evaluate"   
| arre numero |

 arre:= #( 0 0 0 0 ).!

"evaluate"   
| a numero |

 a:= #( 0 0 0 0 ).
  a at:1!

"evaluate"   
| a numero |

 a:= #( 1 0 0 0 ).
  a at:1!

"evaluate"   
| a numero |

 a:= #( 0 0 0 0 ).


  [numero ~= 600000 ] whileTrue:[


                                                      numero:=(Prompter prompt:'ingrese un numero ' default:'' )asInteger.

                                                    (( numero \\ 2)=0) ifTrue:[a at:1put:((a at:1)+1)].
                                                      (( numero \\ 3)=0) ifTrue:[a at:2 put:((a at:2)+1)].
                                                       (( numero \\ 5)=0) ifTrue:[a at:3 put:((a at:3)+1)].
                                                         (( numero \\ 7)=0) ifTrue:[a at:4 put:((a at:4)+1)].


                                                    ].!

"evaluate"   
| a numero |

 a:= #( 0 0 0 0 ).


  [numero ~= 600000 ] whileTrue:[


                                                      numero:=(Prompter prompt:'ingrese un numero ' default:'' )asInteger.

                                                    (( numero \\ 2)=0) ifTrue:[a at:1put:((a at:1)+1)].
                                                      (( numero \\ 3)=0) ifTrue:[a at:2 put:((a at:2)+1)].
                                                       (( numero \\ 5)=0) ifTrue:[a at:3 put:((a at:3)+1)].
                                                         (( numero \\ 7)=0) ifTrue:[a at:4 put:((a at:4)+1)].


                                                    ].

MessageBox message:'la cantidad de multiplos de 2 son :', (a at:1) asString,
                                       'la cantidad de multiplos de 3 son :',(a at:2) asString,
                                       'la cantidad de multiplos de 5 son :',(a at:3) asString,
                                        'la cantidad de multiplos de 7 son :',(a at:4) asString.!

"evaluate"   
| a numero |

 a:= #( 0 0 0 0 ).


  [numero ~= 600000 ] whileTrue:[


                                                      numero:=(Prompter prompt:'ingrese un numero ' default:'' )asInteger.

                                                    (( numero \\ 2)=0) ifTrue:[a at:1put:((a at:1)+1)].
                                                      (( numero \\ 3)=0) ifTrue:[a at:2 put:((a at:2)+1)].
                                                       (( numero \\ 5)=0) ifTrue:[a at:3 put:((a at:3)+1)].
                                                         (( numero \\ 7)=0) ifTrue:[a at:4 put:((a at:4)+1)].


                                                    ].

MessageBox message:'la cantidad de multiplos de 2 son :', (a at:1) asString,
                                       'la cantidad de multiplos de 3 son :',(a at:2) asString,
                                       'la cantidad de multiplos de 5 son :',(a at:3) asString,
                                        'la cantidad de multiplos de 7 son :',(a at:4) asString.!

"evaluate"   
| a numero |

 a:= #( 0 0 0 0 ).


  [numero ~= 600000 ] whileTrue:[


                                                      numero:=(Prompter prompt:'ingrese un numero ' default:'' )asInteger.

                                                    (( numero \\ 2)=0) ifTrue:[a at:1put:((a at:1)+1)].
                                                      (( numero \\ 3)=0) ifTrue:[a at:2 put:((a at:2)+1)].
                                                       (( numero \\ 5)=0) ifTrue:[a at:3 put:((a at:3)+1)].
                                                         (( numero \\ 7)=0) ifTrue:[a at:4 put:((a at:4)+1)].

                                                            numero:=(Prompter prompt:'para salir oprima 600000 ' default:'' )asInteger.

                                                    ].

MessageBox message:'la cantidad de multiplos de 2 son :', (a at:1) asString,
                                       'la cantidad de multiplos de 3 son :',(a at:2) asString,
                                       'la cantidad de multiplos de 5 son :',(a at:3) asString,
                                        'la cantidad de multiplos de 7 son :',(a at:4) asString.!

"evaluate"  
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]
                                    ifFalse:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Falso' ]!

"evaluate"
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]
                                    ifFalse:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Falso' ].!

"evaluate"   
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar==ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]
                                    ifFalse:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Falso' ].!

"evaluate"  
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]!

"evaluate"  
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]
                                    ifFalse:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Falso' ].!

"evaluate"   
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ].!

"evaluate" 
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]
                                    ifFalse:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Falso' ].!

"evaluate"   
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]
                                    ifFalse:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Falso' ].!

"evaluate"   
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]
                                    ifFalse:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Falso' ].!

"evaluate"   
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso) ifTrue:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Verdadero' ]
                                    ifFalse:[ MessageBox message:'decir que el numero ', ingreso asString, ' es Falso' ].!

"evaluate"   
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].!

"evaluate"   
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .]. ^determinar!

"evaluate"   
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .]. ^determinar!

"evaluate"   
| a numero |

 a:= #( 0 0 0 0 ).


  [numero ~= 600000 ] whileTrue:[


                                                      numero:=(Prompter prompt:'ingrese un numero ' default:'' )asInteger.

                                                    (( numero \\ 2)=0) ifTrue:[a at:1put:((a at:1)+1)].
                                                      (( numero \\ 3)=0) ifTrue:[a at:2 put:((a at:2)+1)].
                                                       (( numero \\ 5)=0) ifTrue:[a at:3 put:((a at:3)+1)].
                                                         (( numero \\ 7)=0) ifTrue:[a at:4 put:((a at:4)+1)].

                                                            numero:=(Prompter prompt:'para salir oprima 600000 ' default:'' )asInteger.

                                                    ].

MessageBox message:'la cantidad de multiplos de 2 son :', (a at:1) asString,
                                       'la cantidad de multiplos de 3 son :',(a at:2) asString,
                                       'la cantidad de multiplos de 5 son :',(a at:3) asString,
                                        'la cantidad de multiplos de 7 son :',(a at:4) asString.!

"evaluate"  
| ingreso determinar |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es un perfecto (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .]. ^determinar!

"evaluate"   
| ingreso determinar ingreso2 |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es amigo con otro (? ' default:'' ) asInteger.
  ingreso2:= (Prompter prompt:'ingrese un numero para determinar si es amigo con el anterior (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso2) ifTrue:[ MessageBox message:'los numeros ', ingreso asString, ' y', ingreso2 asString, 'son amigos' ]
                                    ifFalse:[ MessageBox message:'los numeros ', ingreso asString, 'y', ingreso2 asString, 'no son amigos' ].!

"evaluate" 
| ingreso determinar ingreso2 |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es amigo con otro (? ' default:'' ) asInteger.
  ingreso2:= (Prompter prompt:'ingrese un numero para determinar si es amigo con el anterior (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso2) ifTrue:[ MessageBox message:'los numeros ', ingreso asString, ' y', ingreso2 asString, 'son amigos' ]
                                    ifFalse:[ MessageBox message:'los numeros ', ingreso asString, 'y', ingreso2 asString, 'no son amigos' ].!

"evaluate" 
| ingreso determinar ingreso2 |

 ingreso:= (Prompter prompt:'ingrese un numero para determinar si es amigo con otro (? ' default:'' ) asInteger.
  ingreso2:= (Prompter prompt:'ingrese un numero para determinar si es amigo con el anterior (? ' default:'' ) asInteger.
      determinar:=0.
1 to: (ingreso) do:[:i| ((ingreso \\ i )=0) ifTrue:[ determinar:= determinar + i] .].

 (determinar=ingreso2) ifTrue:[ MessageBox message:'los numeros ', ingreso asString, ' y', ingreso2 asString, 'son amigos' ]
                                      ifFalse:[ MessageBox message:'los numeros ', ingreso asString, 'y', ingreso2 asString, 'no son amigos' ].!

"evaluate"   
""*** saved image on: Aug 19, 2018 14:34:27 ***""!

"evaluate"  
| coso |

coso:= (Prompter prompt: 'Ingrese algo ' default:' ' ) asUpperCase.!

"evaluate"
| coso |

coso:= (Prompter prompt: 'Ingrese algo ' default:' ' ) .!

"evaluate"   
| coso lista |

coso:= (Prompter prompt: 'Ingrese algo ' default:' ' ) .

lista:=OrderedCollection new.

1 to:(coso size) do:[:i| ( (coso at:i ) isLowerCase ) ifTrue:[ lista add:( (coso at:i ) asUpperCase) ].
                                    ( (coso at:i ) isUpperCase ) ifTrue:[ lista add:(coso at:i) asLowerCase].].!

"evaluate"
| coso lista |

coso:= (Prompter prompt: 'Ingrese algo ' default:' ' ) .

lista:=OrderedCollection new.

1 to:(coso size) do:[:i| ( (coso at:i ) isLowerCase ) ifTrue:[ lista add:( (coso at:i ) asUpperCase) ].
                                    ( (coso at:i ) isUpperCase ) ifTrue:[ lista add:(coso at:i) asLowerCase].].^lista!

"evaluate"  
| ingreso lista |

ingreso:= (Prompter prompt: 'Ingrese algo ' default:' ' ) .

lista:=OrderedCollection new.

1 to:(ingreso size) do:[:i| ( (ingreso at:i ) isLowerCase ) ifTrue:[ lista add:( (ingreso at:i ) asUpperCase) ].
                                    ( (ingreso at:i ) isUpperCase ) ifTrue:[ lista add:(ingreso at:i) asLowerCase].].

MessageBox message:' resultado', lista asString.!

"evaluate"   
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'').
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  ( (ingreso at:i) isLowerCase )   ifTrue:[ lista add: (ingreso at:i).].].^lista!

"evaluate" 
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'').
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  ( (ingreso at:i) isLowerCase )   ifTrue:[ lista add: (ingreso at:i).].].^lista!

"evaluate" 
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'').
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  ( (ingreso at:i) isLowerCase )   ifTrue:[ lista add: ( (ingreso at:i) asUpperCase).].].^lista!

"evaluate"  
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].  ].].!

"evaluate"  
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].  ].]. ^lista!

"evaluate"   
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].  ].]. ^lista!

"evaluate"   
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].  ].]. ^lista!

"evaluate"   
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].  ].]. ^lista!

"evaluate"   
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].  ].]. ^lista!

"evaluate"   
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].
                                                                                               ( ( (ingreso at:i) at: j) isUpperCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asLowerCase ].  ].]. ^lista!

"evaluate" 
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].
                                                                                               ( ( (ingreso at:i) at: j) isUpperCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asLowerCase ].  ].]. ^lista!

"evaluate" 
| ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo' default:'') asArrayOfSubstrings.
lista:= OrderedCollection new.
1 to: ( ingreso size) do:[:i|  1 to: ( (ingreso at:i) size ) do:[:j| ( ( (ingreso at:i) at: j) isLowerCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asUpperCase ].
                                                                                               ( ( (ingreso at:i) at: j) isUpperCase ) ifTrue:[ lista add: ( (ingreso at:i) at:j) asLowerCase ].  ].]. ^lista!

"evaluate" 
| cont cont2 ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo ' default:'') asArrayOfSubstrings.
lista:=OrderedCollection new.
cont:=1.
cont2:=2.
1 to:(ingreso size) do:[:i| (ingreso size) to: 1 by: -1 do:[:j| ((ingreso at:i) = (ingreso at:j)) ifFalse:[MessageBox message:'no es palindromo' ].].].!

"evaluate"   
| cont cont2 ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo ' default:'') asArrayOfSubstrings.
lista:=OrderedCollection new.
cont:=1.
cont2:=2.
1 to:(ingreso size) do:[:i|
(ingreso size) to: 1 by: -1 do:[:j| ((ingreso at:i) = (ingreso at:j)) ifFalse:[MessageBox message:'no es palindromo' ].].].!

"evaluate"  
| cont cont2 ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo ' default:'') asArrayOfSubstrings.
lista:=OrderedCollection new.
cont:=1.
cont2:=2.
1 to:(ingreso size) do:[:i|
(ingreso size) to: 1 by: -1 do:[:j| ((ingreso at:i) ~= (ingreso at:j)) ifTrue:[MessageBox message:'no es palindromo' ].].].!

"evaluate"  
| cont cont2 ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo ' default:'') .
lista:=OrderedCollection new.
cont:=1.
cont2:=2.
1 to:(ingreso size) do:[:i|
(ingreso size) to: 1 by: -1 do:[:j| ((ingreso at:i) ~= (ingreso at:j)) ifTrue:[MessageBox message:'no es palindromo' ].].].!

"evaluate" 
| cont cont2 ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo ' default:'') .
lista:=OrderedCollection new.
cont:=1.
cont2:=2.
1 to:(ingreso size) do:[:i|
(ingreso size) to: 1 by: -1 do:[:j| ((ingreso at:i) ~= (ingreso at:j)) ifTrue:[MessageBox message:'no es palindromo' ].].].!

"evaluate" 
'hola' reversed!

"evaluate"
| lista2 ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo ' default:'') .

(ingreso = (ingreso reversed)) ifTrue:[MessageBox message:'es palindromo']
                                                 ifFalse:[MessageBox message:'no es falso']!

"evaluate"
| lista2 ingreso lista |

ingreso:= (Prompter prompt:'ingrese algo ' default:'') .

(ingreso = (ingreso reversed)) ifTrue:[MessageBox message:'es palindromo']
                                                 ifFalse:[MessageBox message:'no es palindromo'].!

"evaluate"  
| ingreso cont |

ingreso:=(Prompter prompt:'ingrese algo' default:'').
                                      cont:=0.
1 to: (ingreso size) do:[:i| ((ingreso at:i) isVowel) ifTrue:[ cont:= cont + 1 ].].^cont!

"evaluate"
| ingreso cont |

ingreso:=(Prompter prompt:'ingrese algo' default:'').
                                      cont:=0.
1 to: (ingreso size) do:[:i| ((ingreso at:i) isVowel) ifTrue:[ cont:= cont + 1 ].].
MessageBox message:'la cantidad de vocales de ', ingreso asString , 'son ', cont asString.!